import React, { ReactElement, PropsWithChildren, ReactNode, ChangeEvent, SVGProps, InputHTMLAttributes, TextareaHTMLAttributes, JSX } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as zustand_traditional from 'zustand/traditional';
import * as zustand from 'zustand';
import { UseBoundStore, StoreApi } from 'zustand';
import * as zustand_middleware from 'zustand/middleware';
import { DropzoneOptions } from 'react-dropzone';

interface Presettable {
    /** One or many style-preset names registered via `definePreset()` */
    preset?: string | string[];
}

type AvatarSize = 'xs' | 's' | 'm' | 'l' | 'xl';
type AvatarVariant = 'plain' | 'outline';
interface AvatarProps extends React.ImgHTMLAttributes<HTMLImageElement>, Presettable {
    /** Image URL override. */
    src?: string;
    /** Email used for Gravatar lookup when src missing. */
    email?: string;
    /** Size token controlling relative dimensions. */
    size?: AvatarSize;
    /** Visual style variant. */
    variant?: AvatarVariant;
    /** Fallback style when no avatar exists. */
    gravatarDefault?: string;
}
declare const Avatar: React.FC<AvatarProps>;

type IconSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
interface IconProps extends React.HTMLAttributes<HTMLSpanElement>, Presettable {
    /** Iconify icon name, e.g. "mdi:home". */
    icon?: string;
    /**
     * Custom SVG:
     * • **string** – raw `<path …>` data (wrapped in 24×24 viewBox)
     * • **ReactElement** – a full `<svg>` element
     */
    svg?: string | ReactElement<React.SVGProps<SVGSVGElement>>;
    /** Icon size token or explicit CSS size. */
    size?: IconSize | number | string;
    /** Explicit colour override; otherwise inherits `currentColor`. */
    color?: string | undefined;
}
declare const Icon: React.FC<PropsWithChildren<IconProps>>;

type Variant = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'body' | 'subtitle' | 'button';
interface TypographyProps extends React.HTMLAttributes<HTMLElement>, Presettable {
    variant?: Variant;
    bold?: boolean;
    italic?: boolean;
    centered?: boolean;
    noSelect?: boolean;
    fontSize?: string;
    scale?: number;
    autoSize?: boolean;
    color?: string;
    /** Choose a theme font family */
    family?: 'heading' | 'body' | 'mono' | 'button';
    fontFamily?: string;
}
declare const Typography: React.FC<TypographyProps>;

interface ModalProps extends Presettable {
    /** Controlled visiblity */
    open?: boolean;
    /** Default for uncontrolled */
    defaultOpen?: boolean;
    /** Callback fired when the user requests to close (backdrop / ESC) */
    onClose?: () => void;
    /** Dialog semantics (default) or alertdialog semantics */
    variant?: 'dialog' | 'alert';
    /** Dialog title – used for aria‑labelledby when provided */
    title?: ReactNode;
    /** Main body content */
    children?: ReactNode;
    /** Action buttons */
    actions?: ReactNode;
    /** Disable closing via backdrop click */
    disableBackdropClick?: boolean;
    /** Disable closing via ESC key */
    disableEscapeKeyDown?: boolean;
    /** Max width when not fullWidth */
    maxWidth?: number | string;
    /** Stretch to full viewport width minus gutter */
    fullWidth?: boolean;
}
declare const Modal: React.FC<ModalProps>;

type ProgressVariant = 'linear' | 'circular';
type ProgressMode = 'determinate' | 'indeterminate' | 'buffer';
type ProgressSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
interface ProgressProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'children'>, Presettable {
    /** Linear (default) or Circular. */
    variant?: ProgressVariant;
    /** determinate (default), indeterminate, or (linear-only) buffer. */
    mode?: ProgressMode;
    /** 0 – 100 value for determinate / buffer foreground. */
    value?: number;
    /** 0 – 100 secondary/buffer value (linear‑buffer only). */
    buffer?: number;
    /** xs – xl token or custom CSS size */
    size?: ProgressSize | number | string;
    /** Show numeric % inside Circular centre. */
    showLabel?: boolean;
    /** Colour override (defaults to theme.primary). */
    color?: string | undefined;
}
declare const Progress: React.ForwardRefExoticComponent<ProgressProps & React.RefAttributes<HTMLDivElement>>;

interface VideoSource {
    src: string;
    type: 'video/mp4' | 'video/webm' | string;
}
interface VideoTrack {
    src: string;
    kind: 'subtitles' | 'captions' | 'chapters';
    srclang: string;
    label: string;
    default?: boolean;
}
/** Props for the {@link Video} component. */
interface VideoProps extends Presettable {
    /** One or more video sources (MP4/WebM). */
    sources: VideoSource[];
    /** Poster image URL displayed before playback. */
    poster?: string;
    /** Caption or subtitle tracks. */
    tracks?: VideoTrack[];
    /** Display native controls. Defaults to `true`. */
    controls?: boolean;
    /** Autoplay when ready. Defaults to `true`. */
    autoPlay?: boolean;
    /** Mute audio. Defaults to `true` for autoplay compliance. */
    muted?: boolean;
    /** Loop video. */
    loop?: boolean;
    /** CSS width value, e.g. `100%` or `640px`. */
    width?: string;
    /** CSS height value, e.g. `auto` or `360px`. */
    height?: string;
    /** Lazy load when in viewport. */
    lazy?: boolean;
    /** Custom CSS object-fit. Defaults to `contain`. */
    objectFit?: 'contain' | 'cover';
    /** Playback callback. */
    onPlay?(): void;
    /** Pause callback. */
    onPause?(): void;
    /** Fires on each loop. */
    onLoop?(): void;
    /** Error callback. */
    onError?(e: ErrorEvent): void;
    /** Class name passthrough. */
    className?: string;
    /** Style passthrough. */
    style?: React.CSSProperties;
}
declare const Video: React.FC<VideoProps>;

interface ImageProps extends Omit<React.ImgHTMLAttributes<HTMLImageElement>, 'width' | 'height'>, Presettable {
    /** Image source URL */
    src: string;
    /** CSS width value (number ⇒ px) */
    width?: number | string;
    /** CSS height value (number ⇒ px) */
    height?: number | string;
    /** Object-fit value */
    objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
    /** Border radius */
    rounded?: number | string;
    /** Lazy load image when visible */
    lazy?: boolean;
    /** Placeholder src until loaded */
    placeholder?: string;
}
declare const Image: React.FC<ImageProps>;

interface GridProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    columns?: number;
    gap?: number | string;
    adaptive?: boolean;
}
declare const Grid: React.FC<GridProps>;

interface StackProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    direction?: 'row' | 'column';
    /** Number of spacing units or any CSS length. */
    spacing?: number | string | undefined;
    /** If `true`, children wrap when they run out of space. Defaults to
     *  `true` for `row`, `false` for `column`. */
    wrap?: boolean;
    /** Remove built‑in margin and padding */
    compact?: boolean;
}
declare const Stack: React.FC<StackProps>;

type Breakpoint = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type ThemeMode = 'light' | 'dark';
interface Theme {
    colors: Record<string, string>;
    /** Returns a CSS length for the given number of spacing units */
    spacing: (units: number) => string;
    /** Base unit used by the spacing helper */
    spacingUnit: string;
    breakpoints: Record<Breakpoint, number>;
    typography: Record<string, Record<Breakpoint, string>>;
    fonts: {
        heading: string;
        body: string;
        mono: string;
        button: string;
    };
}
interface ThemeStore {
    mode: ThemeMode;
    theme: Theme;
    setMode: (m: ThemeMode) => void;
    toggleMode: () => void;
    setTheme: (patch: Partial<Theme>) => void;
}
declare const useTheme: zustand_traditional.UseBoundStoreWithEqualityFn<zustand.StoreApi<ThemeStore>>;

interface ChildMetrics {
    width: number;
    height: number;
    top: number;
    left: number;
}
interface SurfaceState {
    width: number;
    height: number;
    breakpoint: Breakpoint;
    hasScrollbar: boolean;
    element: HTMLDivElement | null;
    children: Map<string, ChildMetrics>;
    registerChild: (id: string, node: HTMLElement, cb?: (metrics: ChildMetrics) => void) => void;
    unregisterChild: (id: string) => void;
}
declare function useSurface(): SurfaceState;
declare function useSurface<U>(selector: (state: SurfaceState) => U, equality?: (a: U, b: U) => boolean): U;

interface SurfaceProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    /** Fixed‑position full‑screen surface when true (default). */
    fullscreen?: boolean;
}
declare const Surface: React.FC<SurfaceProps>;

interface BoxProps extends React.ComponentProps<'div'>, Presettable {
    background?: string | undefined;
    textColor?: string | undefined;
    centered?: boolean;
    compact?: boolean;
}
declare const Box: React.FC<BoxProps>;

type PanelVariant = 'main' | 'alt';
interface PanelProps extends React.ComponentProps<'div'>, Presettable {
    variant?: PanelVariant;
    fullWidth?: boolean;
    /** Explicit background override */
    background?: string | undefined;
    /** Centre contents & propagate intent via CSS var */
    centered?: boolean;
    /** Remove built‑in margin and padding */
    compact?: boolean;
}
declare const Panel: React.FC<PanelProps>;

type ButtonVariant = 'contained' | 'outlined';
type ButtonSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type ButtonToken = 'primary' | 'secondary' | 'tertiary';
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, Presettable {
    color?: ButtonToken | string;
    textColor?: ButtonToken | string;
    variant?: ButtonVariant;
    size?: ButtonSize | number | string;
    fullWidth?: boolean;
}
declare const Button: React.FC<ButtonProps>;

type CheckboxSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
interface CheckboxProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'type' | 'size' | 'onChange' | 'value' | 'defaultValue'>, Presettable {
    checked?: boolean;
    defaultChecked?: boolean;
    name: string;
    label?: ReactNode;
    size?: CheckboxSize | number | string;
    onChange?: (checked: boolean, event: ChangeEvent<HTMLInputElement>) => void;
}
declare const Checkbox: React.ForwardRefExoticComponent<CheckboxProps & React.RefAttributes<HTMLInputElement>>;

/**
 * Runtime state slice for any form.
 */
interface FormStore<T extends Record<string, any>> {
    /** Current values keyed by field name. */
    values: T;
    /** Imperative setter for a single field. */
    setField: <K extends keyof T>(key: K, value: T[K]) => void;
    /** Resets all values to their original defaults. */
    reset: () => void;
}
/**
 * **createFormStore** – one-liner helper that returns a _typed_ Zustand hook
 * for local form state.
 *
 * ```ts
 * const useLoginForm = createFormStore({ email:'', password:'' });
 * ```
 */
declare function createFormStore<T extends Record<string, any>>(initial: T): zustand_traditional.UseBoundStoreWithEqualityFn<zustand.StoreApi<FormStore<T>>>;

declare const useForm: <T extends Record<string, any>>() => FormStore<T>;
interface FormControlProps<T extends Record<string, any>> extends Omit<React.FormHTMLAttributes<HTMLFormElement>, 'onSubmit'>, Presettable {
    /**
     * The **Zustand hook** produced by `createFormStore(initialValues)`.
     * It’s the usual `const useForm = createFormStore(...)` function.
     */
    useStore: UseBoundStore<StoreApi<FormStore<T>>>;
    /**
     * Fires after native submit is intercepted – gives you typed values.
     */
    onSubmitValues?: (values: T, event: React.FormEvent<HTMLFormElement>) => void;
}
declare function FormControl<T extends Record<string, any>>({ useStore, onSubmitValues, preset: p, className, children, ...rest }: FormControlProps<T>): react_jsx_runtime.JSX.Element;

type IconButtonVariant = 'contained' | 'outlined';
type IconButtonSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
interface IconButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, Presettable {
    variant?: IconButtonVariant;
    size?: IconButtonSize | number | string;
    icon?: string;
    svg?: string | ReactElement<SVGProps<SVGSVGElement>>;
    /** Colour override for the glyph */
    iconColor?: string | undefined;
}
declare const IconButton: React.FC<IconButtonProps>;

type RadioSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
interface RadioGroupProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'>, Presettable {
    value?: string;
    defaultValue?: string;
    name?: string;
    row?: boolean;
    size?: RadioSize | number | string;
    /** Gap between options */
    spacing?: number | string;
    onChange?: (val: string) => void;
    children: ReactNode;
}
interface RadioProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'type' | 'size' | 'onChange'>, Presettable {
    value: string;
    label?: string;
    size?: RadioSize | number | string;
    children?: ReactNode;
}
declare const RadioGroup: React.FC<RadioGroupProps>;
declare const Radio: React.ForwardRefExoticComponent<RadioProps & React.RefAttributes<HTMLInputElement>>;

type Primitive$1 = string | number;
type SelectSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
interface SelectProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange' | 'defaultValue' | 'children'>, Presettable {
    /** Controlled value (single) or array (multiple). */
    value?: Primitive$1 | Primitive$1[];
    /** Uncontrolled initial value. */
    initialValue?: Primitive$1 | Primitive$1[];
    /** Callback fired whenever selection changes. */
    onChange?: (v: Primitive$1 | Primitive$1[]) => void;
    /** Multiple-selection mode. */
    multiple?: boolean;
    /** Placeholder when nothing selected. */
    placeholder?: string;
    /** Size token or custom measurement */
    size?: SelectSize | number | string;
    disabled?: boolean;
    /** Field name for FormControl binding. */
    name?: string;
    /** Option nodes (see Select.Option). */
    children: React.ReactNode;
}
interface OptionProps extends React.LiHTMLAttributes<HTMLLIElement> {
    value: Primitive$1;
    disabled?: boolean;
}
declare const Option: React.FC<OptionProps>;
declare const Forward: React.ForwardRefExoticComponent<SelectProps & React.RefAttributes<HTMLDivElement>> & {
    Option: typeof Option;
};

type Primitive = string | number;
interface MetroSelectProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'>, Presettable {
    value?: Primitive;
    defaultValue?: Primitive;
    gap?: number | string;
    onChange?: (v: Primitive) => void;
    children: React.ReactNode;
}
interface MetroOptionProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    value: Primitive;
    icon: string | React.ReactElement;
    label: React.ReactNode;
    disabled?: boolean;
}
interface MetroSelectComponent extends React.FC<MetroSelectProps> {
    Option: React.FC<MetroOptionProps>;
}
declare const MetroSelect: MetroSelectComponent;

type SliderSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type SnapMode = 'none' | 'step' | 'presets';
interface SliderProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'>, Presettable {
    /** Controlled value. */
    value?: number;
    /** Default for uncontrolled usage. */
    defaultValue?: number;
    /** Fires on every change (pointer + keyboard). */
    onChange?: (value: number) => void;
    min?: number;
    max?: number;
    /** Fixed increment when `snap="step"`; defaults to 1. */
    step?: number;
    /** Preset snap points when `snap="presets"`. */
    presets?: number[];
    /** Snap behaviour. */
    snap?: SnapMode;
    /** Number of decimal places allowed. Default 0 (integers only). */
    precision?: number;
    /** Show live numeric value above thumb. */
    showValue?: boolean;
    /** Show min/max labels beneath the track ends. */
    showMinMax?: boolean;
    /** Show tick marks (follows snap points or `ticks`). */
    showTicks?: boolean;
    /** Custom tick set (overrides derived ticks). */
    ticks?: number[];
    /** Optional FormControl binding. */
    name?: string;
    size?: SliderSize | number | string;
    disabled?: boolean;
}
declare const Slider: React.ForwardRefExoticComponent<SliderProps & React.RefAttributes<HTMLDivElement>>;

type SwitchSize = 'sm' | 'md' | 'lg';
interface SwitchProps extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'onChange'>, Presettable {
    /** Controlled checked state. */
    checked?: boolean;
    /** Default state for uncontrolled usage. */
    defaultChecked?: boolean;
    /** Callback for state changes (fires for both modes). */
    onChange?: (checked: boolean) => void;
    /** Optional form field name (required to bind into FormControl). */
    name?: string;
    /** Visual size; defaults to `md`. */
    size?: SwitchSize;
}
declare const Switch: React.ForwardRefExoticComponent<SwitchProps & React.RefAttributes<HTMLButtonElement>>;

type InputProps = InputHTMLAttributes<HTMLInputElement>;
type TextareaProps = TextareaHTMLAttributes<HTMLTextAreaElement>;
interface FieldCommon extends Presettable {
    name: string;
    label?: string;
    helperText?: string;
    error?: boolean;
    /** Stretch the wrapper to fill available width */
    fullWidth?: boolean;
}
type TextFieldProps = (FieldCommon & InputProps & {
    as?: 'input';
    rows?: never;
}) | (FieldCommon & TextareaProps & {
    as: 'textarea';
});
declare const TextField: React.ForwardRefExoticComponent<TextFieldProps & React.RefAttributes<HTMLInputElement | HTMLTextAreaElement>>;

interface IteratorProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange'>, Presettable {
    value?: number;
    defaultValue?: number;
    onChange?: (value: number) => void;
    name?: string;
    min?: number;
    max?: number;
    step?: number;
    width?: number | string;
}
declare const Iterator: React.ForwardRefExoticComponent<IteratorProps & React.RefAttributes<HTMLInputElement>>;

interface AccordionProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'>, Presettable {
    defaultOpen?: number | number[];
    open?: number | number[];
    multiple?: boolean;
    onOpenChange?: (open: number[]) => void;
    headingLevel?: 1 | 2 | 3 | 4 | 5 | 6;
    constrainHeight?: boolean;
}
interface AccordionItemProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    header: ReactNode;
    index?: number;
    disabled?: boolean;
    children: ReactNode;
}
declare const Accordion: React.FC<AccordionProps> & {
    Item: React.FC<AccordionItemProps>;
};

type AppBarToken = 'primary' | 'secondary' | 'tertiary';
interface AppBarProps extends React.HTMLAttributes<HTMLElement>, Presettable {
    color?: AppBarToken | string;
    textColor?: AppBarToken | string;
    left?: React.ReactNode;
    right?: React.ReactNode;
}
declare const AppBar: React.FC<AppBarProps>;

type AIProvider = 'openai' | 'anthropic';
declare function encrypt(plaintext: string, passphrase: string): Promise<string>;
declare function decrypt(cipherB64: string, passphrase: string): Promise<string>;
type KeyState = {
    apiKey: string | null;
    provider: AIProvider | null;
    model: string | null;
    cipher: string | null;
    passphrase: string | null;
    setKey: (k: string, provider: AIProvider, pass?: string) => Promise<void>;
    setModel: (m: string) => void;
    applyPassphrase: (pass: string) => Promise<boolean>;
    clearKey: () => void;
};
declare const useAIKey: zustand_traditional.UseBoundStoreWithEqualityFn<Omit<zustand.StoreApi<KeyState>, "persist"> & {
    persist: {
        setOptions: (options: Partial<zustand_middleware.PersistOptions<KeyState, unknown>>) => void;
        clearStorage: () => void;
        rehydrate: () => Promise<void> | void;
        hasHydrated: () => boolean;
        onHydrate: (fn: (state: KeyState) => void) => () => void;
        onFinishHydration: (fn: (state: KeyState) => void) => () => void;
        getOptions: () => Partial<zustand_middleware.PersistOptions<KeyState, unknown>>;
    };
}>;
declare function sendChat(messages: any[], model?: string, provider?: AIProvider, apiKey?: string, endpoint?: string): Promise<any>;

interface ChatMessage {
    role: 'system' | 'user' | 'assistant' | 'function' | 'tool';
    content: string;
    name?: string;
    /** Show animated typing indicator */
    typing?: boolean;
    /** Apply fade animation when first rendered */
    animate?: boolean;
}
interface ChatProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onSubmit'>, Presettable {
    messages: ChatMessage[];
    onSend?: (message: ChatMessage) => void;
    /** Avatar image for user messages */
    userAvatar?: string;
    /** Avatar image for system / assistant messages */
    systemAvatar?: string;
    placeholder?: string;
    disableInput?: boolean;
    constrainHeight?: boolean;
    apiKey?: string;
    provider?: AIProvider;
    model?: string;
    onModelChange?: (m: string) => void;
}
declare const LLMChat: React.FC<ChatProps>;

interface RichMessage {
    role: 'system' | 'user' | 'assistant' | 'function' | 'tool';
    content: React.ReactNode;
    /** Optional interactive form to collect a canned response */
    form?: React.ComponentType<{
        onSubmit: (value: string) => void;
    }>;
    name?: string;
    typing?: boolean;
    animate?: boolean;
}
interface RichChatProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onSubmit'>, Presettable {
    messages: RichMessage[];
    /** Called when a form message collects a response */
    onFormSubmit?: (value: string, index: number) => void;
    onSend?: (message: RichMessage) => void;
    userAvatar?: string;
    systemAvatar?: string;
    placeholder?: string;
    disableInput?: boolean;
    constrainHeight?: boolean;
}
declare const RichChat: React.FC<RichChatProps>;

type DrawerAnchor = 'left' | 'right' | 'top' | 'bottom';
interface DrawerProps extends Presettable {
    /** Controlled visibility */
    open?: boolean;
    /** Default for uncontrolled */
    defaultOpen?: boolean;
    /** Drawer side */
    anchor?: DrawerAnchor;
    /** Callback fired when user requests close */
    onClose?: () => void;
    /** Size (width or height depending on anchor) */
    size?: number | string;
    /** Disable closing via backdrop click */
    disableBackdropClick?: boolean;
    /** Disable closing via ESC key */
    disableEscapeKeyDown?: boolean;
    /** Drawer remains visible without backdrop */
    persistent?: boolean;
    /** Adaptive behaviour (persistent in landscape, overlay in portrait) */
    adaptive?: boolean;
    /** Icon for the portrait toggle button */
    toggleIcon?: string;
    /** Close button icon when portrait */
    closeIcon?: string;
    /** Drawer contents */
    children?: React.ReactNode;
}
declare const Drawer: React.FC<DrawerProps>;

interface DateSelectorProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'>, Presettable {
    /** Controlled ISO date value (YYYY-MM-DD). */
    value?: string;
    /** Default value for uncontrolled usage. */
    defaultValue?: string;
    /** Fires with ISO value when selection changes. */
    onChange?: (value: string) => void;
    /** FormControl field name. */
    name?: string;
    /** Earliest selectable ISO date (YYYY-MM-DD). */
    minDate?: string;
    /** Latest selectable ISO date (YYYY-MM-DD). */
    maxDate?: string;
    /** Enable dual start/end selection mode. */
    range?: boolean;
    /** Controlled end date when `range` is true. */
    endValue?: string;
    /** Default end date for uncontrolled range mode. */
    defaultEndValue?: string;
    /** Fires with start and end ISO values when range changes. */
    onRangeChange?: (start: string, end: string) => void;
}
declare const DateSelector: React.FC<DateSelectorProps>;

interface ListProps<T> extends Omit<React.HTMLAttributes<HTMLUListElement>, 'children'>, Presettable {
    data: T[];
    getTitle: (item: T) => React.ReactNode;
    getSubtitle?: (item: T) => React.ReactNode;
    striped?: boolean;
    /** If `undefined`, non-striped lists hover by default. */
    hoverable?: boolean;
    onReorder?: (items: T[]) => void;
}
declare function List<T>({ data, getTitle, getSubtitle, striped, hoverable, onReorder, preset: p, className, style, ...rest }: ListProps<T>): react_jsx_runtime.JSX.Element;

interface LoadingBackdropProps {
    fading?: boolean;
    showSpinner?: boolean;
}
declare const LoadingBackdrop: React.FC<LoadingBackdropProps>;

interface PaginationProps extends Omit<React.HTMLAttributes<HTMLElement>, 'onChange'>, Presettable {
    /** Total number of pages (≥ 1). */
    count: number;
    /** Currently-selected page (1-based). */
    page?: number;
    /** Called with **new page** when user clicks. */
    onChange?: (page: number) => void;
}
declare const Pagination: React.FC<PaginationProps>;

interface ParallaxState {
    scrollY: number;
    scrollX: number;
}
/** Read current scroll offsets (provided by <ParallaxScroll>). */
declare const useParallax: () => ParallaxState;
interface ParallaxScrollProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    /** Track horizontal scroll in addition to vertical. */
    trackX?: boolean;
}
declare const ParallaxScroll: React.FC<ParallaxScrollProps>;
interface ParallaxLayerProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    speed?: number;
    axis?: 'y' | 'x';
}
declare const ParallaxLayer: React.FC<ParallaxLayerProps>;
type MediaType = 'image' | 'video';
interface ParallaxBackgroundProps extends Omit<ParallaxLayerProps, 'children'>, Presettable {
    /** Source for JPG / WEBP / WEBM (auto-detects type if omitted). */
    src: string;
    /** Force media type (otherwise guessed by file extension). */
    mediaType?: MediaType;
    /** Optional poster frame for video. */
    poster?: string;
    /** Video attributes */
    loop?: boolean;
    muted?: boolean;
    autoPlay?: boolean;
    preload?: 'none' | 'metadata' | 'auto';
}
declare const ParallaxBackground: React.FC<ParallaxBackgroundProps>;

type DismissFn = () => void;
declare const useSnackbar: () => DismissFn | null;
interface SnackbarProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    /** Controlled open state – omit for uncontrolled */
    open?: boolean;
    /** Called when the snackbar has fully hidden */
    onClose?: () => void;
    /** Auto-hide after N ms – `null` disables (default = 4000 ms) */
    autoHideDuration?: number | null;
    /** Convenience message when no children supplied            */
    message?: React.ReactNode;
    /** Disable the internal flex stack (children render 1:1)    */
    noStack?: boolean;
}
declare const Snackbar: React.FC<SnackbarProps>;

interface SpeedDialAction {
    icon: React.ReactNode;
    label: string;
    onClick: () => void;
}
interface SpeedDialProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    /** Icon for the main FAB (usually a ➕). */
    icon: React.ReactNode;
    /** Speed-dial actions revealed when the FAB is toggled. */
    actions: SpeedDialAction[];
    /** Direction in which actions should expand. */
    direction?: 'up' | 'down' | 'left' | 'right';
}
declare const SpeedDial: React.FC<SpeedDialProps>;

interface StepperProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    steps: React.ReactNode[];
    active?: number;
}
declare const Stepper: React.FC<StepperProps>;

interface TableColumn<T> {
    header: React.ReactNode;
    accessor?: keyof T | ((row: T) => unknown);
    render?: (row: T, idx: number) => React.ReactNode;
    align?: 'left' | 'center' | 'right';
    sortable?: boolean | ((a: T, b: T) => number);
}
interface TableProps<T> extends Omit<React.TableHTMLAttributes<HTMLTableElement>, 'children'>, Presettable {
    data: T[];
    columns: TableColumn<T>[];
    striped?: boolean;
    hoverable?: boolean;
    dividers?: boolean;
    selectable?: 'single' | 'multi' | undefined;
    initialSort?: {
        index: number;
        desc?: boolean;
    };
    onSortChange?: (index: number, desc: boolean) => void;
    onSelectionChange?: (selected: T[]) => void;
    constrainHeight?: boolean;
}
declare function Table<T extends object>({ data, columns, striped, hoverable, dividers, selectable, initialSort, onSortChange, onSelectionChange, constrainHeight, preset: p, className, style, ...rest }: TableProps<T>): react_jsx_runtime.JSX.Element;

interface DropzoneProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onDrop'>, Presettable {
    /** Allowable file types (same as react-dropzone `accept`) */
    accept?: DropzoneOptions['accept'];
    /** Display previews for accepted files */
    showPreviews?: boolean;
    /** Show file icons and names rather than thumbnails */
    showFileList?: boolean;
    /** Called whenever the file list changes */
    onFilesChange?: (files: File[]) => void;
    /** Maximum file count */
    maxFiles?: number;
    /** Allow multiple file selection */
    multiple?: boolean;
    /** Callback for when files are dropped */
    onDrop?: DropzoneOptions['onDrop'];
    /** Stretch to fill parent width */
    fullWidth?: boolean;
}
declare const Dropzone: React.FC<DropzoneProps>;

interface TabsProps extends Omit<React.HTMLAttributes<HTMLDivElement>, 'onChange'>, Presettable {
    active?: number;
    defaultActive?: number;
    onTabChange?: (i: number) => void;
    orientation?: 'horizontal' | 'vertical';
    placement?: 'top' | 'bottom' | 'left' | 'right';
    centered?: boolean;
}
interface TabProps extends React.ButtonHTMLAttributes<HTMLButtonElement>, Presettable {
    index?: number;
    label?: ReactNode;
    tooltip?: ReactNode;
}
interface TabPanelProps extends React.HTMLAttributes<HTMLDivElement>, Presettable {
    index?: number;
    keepMounted?: boolean;
}
declare const Tabs: React.FC<TabsProps> & {
    Tab: React.FC<TabProps>;
    Panel: React.FC<TabPanelProps>;
};

type Placement = 'top' | 'bottom' | 'left' | 'right';
interface TooltipProps extends Presettable {
    title: ReactNode;
    placement?: Placement;
    arrow?: boolean;
    enterDelay?: number;
    leaveDelay?: number;
    open?: boolean;
    defaultOpen?: boolean;
    disableHoverListener?: boolean;
    disableFocusListener?: boolean;
    disableTouchListener?: boolean;
    onOpen?: () => void;
    onClose?: () => void;
    children: ReactElement;
}
declare const Tooltip: React.FC<TooltipProps>;

interface TreeNode<T> {
    id: string;
    data: T;
    children?: TreeNode<T>[];
}
interface TreeProps<T> extends Omit<React.HTMLAttributes<HTMLUListElement>, 'children'>, Presettable {
    nodes: TreeNode<T>[];
    getLabel: (node: T) => React.ReactNode;
    defaultExpanded?: string[];
    expanded?: string[];
    onExpandedChange?: (expanded: string[]) => void;
    /** Active selection (controlled). */
    selected?: string;
    /** Default selection for uncontrolled usage. */
    defaultSelected?: string;
    onNodeSelect?: (node: T) => void;
    variant?: 'chevron' | 'list' | 'files';
}
declare function Tree<T>({ nodes, getLabel, defaultExpanded, expanded: expandedProp, onExpandedChange, selected: selectedProp, defaultSelected, onNodeSelect, variant, preset: p, className, ...rest }: TreeProps<T>): react_jsx_runtime.JSX.Element;

interface MarkdownProps extends React.HTMLAttributes<HTMLDivElement> {
    /** Raw markdown text */
    data: string;
    /** Optional override for code block background */
    codeBackground?: string;
}
declare const Markdown: React.FC<MarkdownProps>;

interface KeyModalProps {
    open: boolean;
    onClose?: () => void;
}
declare function KeyModal({ open, onClose }: KeyModalProps): react_jsx_runtime.JSX.Element | null;

declare const styleCache: Map<string, string>;
declare const globalSheet: CSSStyleSheet;
declare function styled<Tag extends keyof JSX.IntrinsicElements>(tag: Tag): <ExtraProps extends Record<string, any> = {}>(strings: TemplateStringsArray, ...exprs: Array<string | number | false | null | undefined | ((props: ExtraProps & JSX.IntrinsicElements[Tag]) => string | number | false | null | undefined)>) => React.ForwardRefExoticComponent<React.PropsWithoutRef<ExtraProps & JSX.IntrinsicElements[Tag] & {
    className?: string;
}> & React.RefAttributes<Tag extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[Tag] : HTMLElement>>;
declare function keyframes(strings: TemplateStringsArray, ...exprs: Array<string | number | false | null | undefined>): string;

type CSSFn = (theme: Theme) => string;
declare function definePreset(name: string, cssFn: CSSFn): void;
declare function preset(names: string | string[]): string;
declare function presetHas(names: string | string[], property: string): boolean;

interface FontState {
    loading: number;
    ready: boolean;
    start: () => void;
    finish: () => void;
}
declare const useFonts: zustand_traditional.UseBoundStoreWithEqualityFn<zustand.StoreApi<FontState>>;

interface GoogleFontOptions {
    preload?: boolean;
}
interface CustomFont {
    name: string;
    src: string;
}
type Font = string | CustomFont;

declare function createInitialTheme(patch: Partial<Omit<Theme, 'fonts'> & {
    fonts?: Partial<Record<'heading' | 'body' | 'mono' | 'button', Font>>;
}>, extras?: Font[], options?: GoogleFontOptions): Promise<void>;
declare function useInitialTheme(patch: Partial<Omit<Theme, 'fonts'> & {
    fonts?: Partial<Record<'heading' | 'body' | 'mono' | 'button', Font>>;
}>, extras?: Font[], options?: GoogleFontOptions): void;

declare function useGoogleFonts(extras?: Font[], options?: GoogleFontOptions): void;

export { type AIProvider, Accordion, type AccordionItemProps, type AccordionProps, AppBar, type AppBarProps, type AppBarToken, Avatar, type AvatarProps, type AvatarSize, type AvatarVariant, Box, type BoxProps, type Breakpoint, Button, type ButtonProps, type ButtonSize, type ButtonToken, type ButtonVariant, type ChatMessage, type ChatProps, Checkbox, type CheckboxProps, type CheckboxSize, type CustomFont, DateSelector, type DateSelectorProps, Drawer, type DrawerAnchor, type DrawerProps, Dropzone, type DropzoneProps, type Font, FormControl, type FormControlProps, type FormStore, Grid, type GridProps, Icon, IconButton, type IconButtonProps, type IconButtonSize, type IconButtonVariant, type IconProps, type IconSize, Image, type ImageProps, Iterator, type IteratorProps, KeyModal, LLMChat, List, type ListProps, LoadingBackdrop, type LoadingBackdropProps, Markdown, type MarkdownProps, type MetroOptionProps, MetroSelect, type MetroSelectProps, Modal, type ModalProps, Pagination, type PaginationProps, Panel, type PanelProps, type PanelVariant, ParallaxBackground, type ParallaxBackgroundProps, ParallaxLayer, type ParallaxLayerProps, ParallaxScroll, type ParallaxScrollProps, Progress, type ProgressMode, type ProgressProps, type ProgressSize, type ProgressVariant, Radio, RadioGroup, type RadioGroupProps, type RadioProps, type RadioSize, RichChat, type RichChatProps, type RichMessage, Forward as Select, type OptionProps as SelectOptionProps, type SelectProps, Slider, type SliderProps, Snackbar, type SnackbarProps, SpeedDial, type SpeedDialAction, type SpeedDialProps, Stack, type StackProps, Stepper, type StepperProps, Surface, type SurfaceProps, Switch, type SwitchProps, type TabPanelProps, type TabProps, Table, type TableColumn, type TableProps, Tabs, type TabsProps, TextField, type TextFieldProps, type Theme, type ThemeMode, Tooltip, type TooltipProps, Tree, type TreeNode, type TreeProps, Typography, type TypographyProps, type Variant, Video, type VideoProps, type VideoSource, type VideoTrack, createFormStore, createInitialTheme, decrypt, definePreset, encrypt, globalSheet, keyframes, preset, presetHas, sendChat, styleCache, styled, useAIKey, useFonts, useForm, useGoogleFonts, useInitialTheme, useParallax, useSnackbar, useSurface, useTheme };
