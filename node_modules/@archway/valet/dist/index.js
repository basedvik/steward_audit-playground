"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Accordion: () => Accordion,
  AppBar: () => AppBar,
  Avatar: () => Avatar,
  Box: () => Box2,
  Button: () => Button,
  Checkbox: () => Checkbox,
  DateSelector: () => DateSelector,
  Drawer: () => Drawer,
  Dropzone: () => Dropzone,
  FormControl: () => FormControl,
  Grid: () => Grid,
  Icon: () => Icon,
  IconButton: () => IconButton,
  Image: () => Image2,
  Iterator: () => Iterator,
  KeyModal: () => KeyModal,
  LLMChat: () => LLMChat,
  List: () => List,
  LoadingBackdrop: () => LoadingBackdrop,
  Markdown: () => Markdown,
  MetroSelect: () => MetroSelect_default,
  Modal: () => Modal,
  Pagination: () => Pagination,
  Panel: () => Panel,
  ParallaxBackground: () => ParallaxBackground,
  ParallaxLayer: () => ParallaxLayer,
  ParallaxScroll: () => ParallaxScroll,
  Progress: () => Progress,
  Radio: () => Radio,
  RadioGroup: () => RadioGroup,
  RichChat: () => RichChat,
  Select: () => Select_default,
  Slider: () => Slider,
  Snackbar: () => Snackbar,
  SpeedDial: () => SpeedDial,
  Stack: () => Stack,
  Stepper: () => Stepper,
  Surface: () => Surface,
  Switch: () => Switch,
  Table: () => Table,
  Tabs: () => Tabs,
  TextField: () => TextField,
  Tooltip: () => Tooltip,
  Tree: () => Tree,
  Typography: () => Typography,
  Video: () => Video,
  createFormStore: () => createFormStore,
  createInitialTheme: () => createInitialTheme,
  decrypt: () => decrypt,
  definePreset: () => definePreset,
  encrypt: () => encrypt,
  globalSheet: () => globalSheet,
  keyframes: () => keyframes,
  preset: () => preset,
  presetHas: () => presetHas,
  sendChat: () => sendChat,
  styleCache: () => styleCache,
  styled: () => styled,
  useAIKey: () => useAIKey,
  useFonts: () => useFonts,
  useForm: () => useForm,
  useGoogleFonts: () => useGoogleFonts,
  useInitialTheme: () => useInitialTheme,
  useParallax: () => useParallax,
  useSnackbar: () => useSnackbar,
  useSurface: () => useSurface,
  useTheme: () => useTheme
});
module.exports = __toCommonJS(index_exports);

// src/css/createStyled.ts
var import_react2 = __toESM(require("react"));

// src/css/hash.ts
var siphash = __toESM(require("siphash"));
var KEY = siphash.string16_to_key("valet-hash-key!1");
function hashStr(str) {
  return siphash.hash_uint(KEY, str).toString(36);
}

// src/system/surfaceStore.ts
var import_react = __toESM(require("react"));
var import_traditional = require("zustand/traditional");
var createSurfaceStore = () => (0, import_traditional.createWithEqualityFn)((set, get) => {
  const nodes = /* @__PURE__ */ new Map();
  const ro = new ResizeObserver((entries) => {
    const surfEl = get().element;
    const sRect = surfEl ? surfEl.getBoundingClientRect() : { top: 0, left: 0 };
    const scrollTop = surfEl ? surfEl.scrollTop : 0;
    const scrollLeft = surfEl ? surfEl.scrollLeft : 0;
    for (const entry of entries) {
      for (const [id, meta] of nodes) {
        if (meta.node === entry.target) {
          const rect = entry.target.getBoundingClientRect();
          const metrics = {
            width: rect.width,
            height: Math.round(rect.height),
            top: rect.top - sRect.top + scrollTop,
            left: rect.left - sRect.left + scrollLeft
          };
          set((s) => {
            const next = new Map(s.children);
            next.set(id, metrics);
            return { children: next };
          });
          meta.cb?.(metrics);
          break;
        }
      }
    }
  });
  return {
    width: 0,
    height: 0,
    breakpoint: "xs",
    hasScrollbar: false,
    element: null,
    children: /* @__PURE__ */ new Map(),
    registerChild: (id, node, cb) => {
      nodes.set(id, { node, cb });
      ro.observe(node);
      const surfEl = get().element;
      const sRect = surfEl ? surfEl.getBoundingClientRect() : { top: 0, left: 0 };
      const scrollTop = surfEl ? surfEl.scrollTop : 0;
      const scrollLeft = surfEl ? surfEl.scrollLeft : 0;
      const rect = node.getBoundingClientRect();
      const metrics = {
        width: rect.width,
        height: Math.round(rect.height),
        top: rect.top - sRect.top + scrollTop,
        left: rect.left - sRect.left + scrollLeft
      };
      set((s) => {
        const next = new Map(s.children);
        next.set(id, metrics);
        return { children: next };
      });
      cb?.(metrics);
    },
    unregisterChild: (id) => {
      const entry = nodes.get(id);
      if (entry) {
        ro.unobserve(entry.node);
        nodes.delete(id);
      }
      set((s) => {
        const next = new Map(s.children);
        next.delete(id);
        return { children: next };
      });
    }
  };
});
var SurfaceCtx = import_react.default.createContext(null);
function useSurface(selector, equality) {
  const store = import_react.default.useContext(SurfaceCtx);
  if (!store)
    throw new Error("useSurface must be used within a <Surface> component");
  const sel = selector ?? ((s) => s);
  return store(sel, equality);
}

// src/css/createStyled.ts
function labelize(raw) {
  return raw.toLowerCase().replace(/[^a-z0-9_-]+/g, "") || "el";
}
var styleCache = /* @__PURE__ */ new Map();
var injected = /* @__PURE__ */ new Set();
var styleEl = document.createElement("style");
document.head.appendChild(styleEl);
var globalSheet = styleEl.sheet;
function inject(cssId, css) {
  if (injected.has(cssId)) return;
  globalSheet.insertRule(css, globalSheet.cssRules.length);
  injected.add(cssId);
}
function normalizeCSS(css) {
  return css.trim().replace(/\s+/g, " ").replace(/; ?}/g, "}");
}
function filterStyledProps(raw) {
  const clean = {};
  for (const k in raw) if (!k.startsWith("$")) clean[k] = raw[k];
  return clean;
}
function styled(tag) {
  return function styledFactory(strings, ...exprs) {
    const StyledComponent = import_react2.default.forwardRef(
      (props, ref) => {
        const localRef = (0, import_react2.useRef)(null);
        const surface = (0, import_react2.useContext)(SurfaceCtx);
        const idRef = (0, import_react2.useRef)(`el-${Math.random().toString(36).slice(2)}`);
        let rawCSS = "";
        for (let i = 0; i < strings.length; i++) {
          rawCSS += strings[i];
          if (i < exprs.length) {
            const val = typeof exprs[i] === "function" ? exprs[i](props) : exprs[i];
            rawCSS += val ?? "";
          }
        }
        const normalized = normalizeCSS(rawCSS);
        let className = styleCache.get(normalized);
        if (!className) {
          const rawLabel = typeof tag === "string" ? tag : tag.displayName || tag.name || "el";
          const label = labelize(rawLabel);
          className = `z-${label}-${hashStr(normalized)}`;
          inject(`.${className}`, `.${className}{${normalized}}`);
          styleCache.set(normalized, className);
        }
        const merged = [className, props.className].filter(Boolean).join(" ");
        const domProps = filterStyledProps(props);
        (0, import_react2.useLayoutEffect)(() => {
          const el = localRef.current;
          if (!surface || !el) return;
          const id = idRef.current;
          surface.getState().registerChild(id, el, (m) => {
            el.style.setProperty("--valet-el-width", `${m.width}px`);
            el.style.setProperty("--valet-el-height", `${Math.round(m.height)}px`);
          });
          return () => {
            surface.getState().unregisterChild(id);
          };
        }, [surface]);
        return import_react2.default.createElement(tag, {
          ...domProps,
          className: merged,
          ref: (node) => {
            localRef.current = node;
            if (typeof ref === "function") ref(node);
            else if (ref) ref.current = node;
          }
        });
      }
    );
    StyledComponent.displayName = `styled(${String(tag)})`;
    return StyledComponent;
  };
}
function keyframes(strings, ...exprs) {
  let rawCSS = "";
  for (let i = 0; i < strings.length; i++) {
    rawCSS += strings[i];
    if (i < exprs.length) rawCSS += exprs[i] ?? "";
  }
  const normalized = normalizeCSS(rawCSS);
  const animName = `z-kf-${hashStr(normalized)}`;
  if (!injected.has(animName)) {
    inject(
      animName,
      `@keyframes ${animName}{${normalized}}`
    );
  }
  return animName;
}

// src/system/themeStore.ts
var import_traditional2 = require("zustand/traditional");
var spacingUnit = "0.5rem";
var [, baseStr, unitSuffix] = spacingUnit.match(/^([0-9.]+)([a-zA-Z%]+)$/);
var base = parseFloat(baseStr);
var common = {
  spacing: (u) => `${u * base}${unitSuffix}`,
  // spacing(4) → "1rem"
  spacingUnit,
  breakpoints: { xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920 },
  typography: {
    h1: { xs: "2rem", sm: "2.5rem", md: "3rem", lg: "3.5rem", xl: "4rem" },
    h2: { xs: "1.5rem", sm: "2rem", md: "2.5rem", lg: "3rem", xl: "3.5rem" },
    h3: { xs: "1.25rem", sm: "1.5rem", md: "2rem", lg: "2.5rem", xl: "3rem" },
    h4: { xs: "1rem", sm: "1.25rem", md: "1.5rem", lg: "2rem", xl: "2.5rem" },
    h5: { xs: "0.875rem", sm: "1rem", md: "1.25rem", lg: "1.5rem", xl: "2rem" },
    h6: { xs: "0.75rem", sm: "0.875rem", md: "1rem", lg: "1.25rem", xl: "1.5rem" },
    body: { xs: "0.875rem", sm: "1rem", md: "1rem", lg: "1rem", xl: "1rem" },
    subtitle: { xs: "0.75rem", sm: "0.875rem", md: "0.875rem", lg: "1rem", xl: "1rem" },
    button: { xs: "0.875rem", sm: "0.875rem", md: "0.875rem", lg: "1rem", xl: "1rem" }
  },
  fonts: {
    heading: "Roboto",
    body: "Roboto Serif",
    mono: "Roboto Mono",
    button: "Roboto Mono"
  }
};
var lightColors = {
  primary: "#8bb392",
  primaryText: "#090909",
  secondary: "#a7ccc4",
  secondaryText: "#090909",
  tertiary: "#d1e6dc",
  tertiaryText: "#090909",
  primaryButtonText: "#090909",
  secondaryButtonText: "#090909",
  tertiaryButtonText: "#090909",
  background: "#eeeeee",
  backgroundAlt: "#cccccc",
  text: "#090909"
};
var darkColors = {
  primary: "#608066",
  primaryText: "#F7F7F7",
  secondary: "#69807a",
  secondaryText: "#F7F7F7",
  tertiary: "#5d6662",
  tertiaryText: "#F7F7F7",
  primaryButtonText: "#F7F7F7",
  secondaryButtonText: "#F7F7F7",
  tertiaryButtonText: "#F7F7F7",
  background: "#222222",
  backgroundAlt: "#444444",
  text: "#F7F7F7"
};
var useTheme = (0, import_traditional2.createWithEqualityFn)((set, get) => ({
  mode: "dark",
  theme: {
    ...common,
    colors: darkColors
  },
  setMode: (mode) => set((state) => ({
    mode,
    theme: {
      ...common,
      colors: mode === "dark" ? darkColors : lightColors,
      fonts: state.theme.fonts
    }
  })),
  toggleMode: () => get().setMode(get().mode === "dark" ? "light" : "dark"),
  setTheme: (patch) => set((state) => ({ theme: { ...state.theme, ...patch } }))
}));

// src/css/stylePresets.ts
var registry = /* @__PURE__ */ new Map();
var subscribed = false;
function normalise(css) {
  return css.trim().replace(/\s+/g, " ").replace(/; ?}/g, "}");
}
function ensureSubscription() {
  if (subscribed) return;
  subscribed = true;
  useTheme.subscribe(({ theme }) => {
    for (const { cssFn, class: cls, rule } of registry.values()) {
      const nextCSS = normalise(cssFn(theme));
      rule.style.cssText = nextCSS;
    }
  });
}
function definePreset(name, cssFn) {
  if (registry.has(name)) {
    throw new Error(`Style preset \u201C${name}\u201D already exists`);
  }
  ensureSubscription();
  const prefix = name.toLowerCase().replace(/[^a-z0-9_-]+/g, "");
  const className = `zp-${prefix}-${hashStr(name)}`;
  const { theme } = useTheme.getState();
  const rawCSS = normalise(cssFn(theme));
  const ruleText = `.${className}{${rawCSS}}`;
  const index = globalSheet.insertRule(ruleText, globalSheet.cssRules.length);
  const rule = globalSheet.cssRules[index];
  styleCache.set(className, rawCSS);
  registry.set(name, { cssFn, class: className, rule });
}
function preset(names) {
  return (Array.isArray(names) ? names : [names]).map((n) => {
    const entry = registry.get(n);
    if (!entry) throw new Error(`Unknown style preset \u201C${n}\u201D`);
    return entry.class;
  }).join(" ");
}
function presetHas(names, property) {
  const list = Array.isArray(names) ? names : [names];
  for (const name of list) {
    const entry = registry.get(name);
    if (entry && entry.rule.style.getPropertyValue(property)) {
      return true;
    }
  }
  return false;
}

// src/helpers/md5.ts
function md5(str) {
  const x = str2binl(str);
  const len = str.length * 8;
  x[len >> 5] |= 128 << len % 32;
  x[(len + 64 >>> 9 << 4) + 14] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = ff(a, b, c, d, x[i + 0], 7, -680876936);
    d = ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = ff(c, d, a, b, x[i + 10], 17, -42063);
    b = ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = gg(b, c, d, a, x[i + 0], 20, -373897302);
    a = gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = hh(a, b, c, d, x[i + 5], 4, -378558);
    d = hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = hh(d, a, b, c, x[i + 0], 11, -358537222);
    c = hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = ii(a, b, c, d, x[i + 0], 6, -198630844);
    d = ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return binl2hex([a, b, c, d]);
}
function cmn(q, a, b, x, s, t) {
  return safe_add(rotl(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
}
function ff(a, b, c, d, x, s, t) {
  return cmn(b & c | ~b & d, a, b, x, s, t);
}
function gg(a, b, c, d, x, s, t) {
  return cmn(b & d | c & ~d, a, b, x, s, t);
}
function hh(a, b, c, d, x, s, t) {
  return cmn(b ^ c ^ d, a, b, x, s, t);
}
function ii(a, b, c, d, x, s, t) {
  return cmn(c ^ (b | ~d), a, b, x, s, t);
}
function safe_add(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function rotl(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function str2binl(str) {
  const bin = [];
  const mask = 255;
  for (let i = 0; i < str.length * 8; i += 8) {
    bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << i % 32;
  }
  return bin;
}
function binl2hex(bin) {
  const hexTab = "0123456789abcdef";
  let str = "";
  for (let i = 0; i < bin.length * 4; i++) {
    str += hexTab.charAt(bin[i >> 2] >> i % 4 * 8 + 4 & 15) + hexTab.charAt(bin[i >> 2] >> i % 4 * 8 & 15);
  }
  return str;
}

// src/components/primitives/Avatar.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var sizeMap = {
  xs: "1.5rem",
  s: "2rem",
  m: "3rem",
  l: "4rem",
  xl: "6rem"
};
var Img = styled("img")`
  display: inline-block;
  width: ${({ $size }) => $size};
  height: ${({ $size }) => $size};
  border-radius: 50%;
  object-fit: cover;
  ${({ $variant, $stroke }) => $variant === "outline" ? `box-shadow: 0 0 0 0.25rem ${$stroke};` : ""}
`;
var Avatar = ({
  src,
  email,
  size = "m",
  variant = "plain",
  gravatarDefault = "identicon",
  preset: p,
  className,
  ...rest
}) => {
  const rem = sizeMap[size];
  const px = Math.round(parseFloat(rem) * 16);
  let finalSrc = src;
  if (!finalSrc) {
    const hash = email ? md5(email.trim().toLowerCase()) : "";
    finalSrc = `https://www.gravatar.com/avatar/${hash}?s=${px}&d=${encodeURIComponent(gravatarDefault)}`;
  }
  const { theme } = useTheme();
  const stroke = theme.colors.backgroundAlt;
  const presetCls = p ? preset(p) : "";
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    Img,
    {
      ...rest,
      src: finalSrc,
      $size: rem,
      $variant: variant,
      $stroke: stroke,
      className: [presetCls, className].filter(Boolean).join(" ")
    }
  );
};
var Avatar_default = Avatar;

// src/components/primitives/Icon.tsx
var import_react3 = __toESM(require("react"));
var import_react4 = require("@iconify/react");
var import_jsx_runtime2 = require("react/jsx-runtime");
var Wrapper = styled("span")`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 0;
  width: ${({ $size }) => $size};
  height: ${({ $size }) => $size};

  & > svg {
    width: 100%;
    height: 100%;
    flex-shrink: 0;
  }
`;
var sizeMap2 = {
  xs: "0.75em",
  sm: "1em",
  md: "1.5em",
  lg: "2.5em",
  xl: "4em"
};
var Icon = ({
  icon,
  svg,
  size = "md",
  color,
  preset: p,
  className,
  style,
  children,
  ...spanRest
}) => {
  const presetClasses = p ? preset(p) : "";
  const finalSize = typeof size === "number" ? `${size}px` : sizeMap2[size] ?? size;
  const colourStyle = color ? { color } : void 0;
  let content = null;
  if (icon) {
    content = /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      import_react4.Icon,
      {
        icon,
        width: "100%",
        height: "100%",
        color: "currentColor",
        "aria-hidden": spanRest["aria-label"] ? void 0 : true,
        focusable: "false"
      }
    );
  } else if ((0, import_react3.isValidElement)(svg)) {
    const svgEl = svg;
    content = import_react3.default.cloneElement(svgEl, {
      width: "100%",
      height: "100%",
      fill: svgEl.props.fill ?? "currentColor"
    });
  } else if (typeof svg === "string") {
    content = /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      "svg",
      {
        width: "100%",
        height: "100%",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        dangerouslySetInnerHTML: { __html: svg.trim() }
      }
    );
  } else if ((0, import_react3.isValidElement)(children)) {
    const child = children;
    content = import_react3.default.cloneElement(child, {
      width: "100%",
      height: "100%",
      fill: child.props.fill ?? "currentColor"
    });
  } else {
    if (process.env.NODE_ENV !== "production") {
      console.warn("<Icon /> requires `icon`, `svg`, or children containing an <svg>.");
    }
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    Wrapper,
    {
      $size: finalSize,
      className: [presetClasses, className].filter(Boolean).join(" "),
      style: { ...colourStyle, ...style },
      ...spanRest,
      children: content
    }
  );
};
var Icon_default = Icon;

// src/components/primitives/Typography.tsx
var import_react5 = __toESM(require("react"));
var import_shallow = require("zustand/shallow");
var import_jsx_runtime3 = require("react/jsx-runtime");
var mapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  body: "p",
  subtitle: "span",
  button: "span"
};
var Typography = ({
  variant = "body",
  bold = false,
  italic = false,
  fontSize,
  scale,
  autoSize = false,
  color,
  family,
  fontFamily,
  centered,
  noSelect = false,
  preset: p,
  className,
  children,
  ...props
}) => {
  const Tag = mapping[variant];
  const { theme } = useTheme();
  const breakpoint = useSurface((s) => s.breakpoint, import_shallow.shallow);
  const defaultSize = theme.typography[variant].md;
  let size = autoSize ? theme.typography[variant][breakpoint] : defaultSize;
  if (scale != null) size = `calc(${size} * ${scale})`;
  if (fontSize) size = fontSize;
  const presetClasses = p ? preset(p) : "";
  const Component = import_react5.default.useMemo(
    () => styled(Tag)`
        margin: 0;
        color: ${({ $color }) => $color || "var(--valet-text-color, inherit)"};
        font-size: ${({ $size }) => $size};
        font-weight: ${({ $bold }) => $bold ? 700 : 400};
        font-style: ${({ $italic }) => $italic ? "italic" : "normal"};
        line-height: ${({ $variant }) => $variant === "button" ? 1 : 1.4};
        font-family: ${({ $fontFamily, $family, $variant }) => $fontFamily || ($family ? `var(--valet-font-${$family})` : `var(--valet-font-${$variant === "button" ? "button" : $variant.startsWith("h") ? "heading" : "body"})`)};
        ${({ $center }) => $center && `
            text-align: center;
            align-self: center;
            margin-inline: auto;
          `};
        ${({ $noSelect }) => $noSelect && `
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
          `};

        /* Newline & wrapping guards */
        white-space: normal;
        overflow-wrap: anywhere;
        word-break: break-word;
        max-width: 100%;
      `,
    [Tag]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    Component,
    {
      ...props,
      $color: color,
      $fontFamily: fontFamily,
      $family: family,
      $variant: variant,
      $size: size,
      $bold: bold,
      $italic: italic,
      $center: centered,
      $noSelect: noSelect,
      className: [presetClasses, className].filter(Boolean).join(" "),
      children
    }
  );
};
var Typography_default = Typography;

// src/components/layout/Modal.tsx
var import_react6 = require("react");
var import_react_dom = require("react-dom");
var import_jsx_runtime4 = require("react/jsx-runtime");
var Backdrop = styled("div")`
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.55);
    backdrop-filter: blur(2px);
    opacity: ${({ $fade }) => $fade ? 0 : 1};
    transition: opacity 200ms ease;
    z-index: 9998;
  `;
var Box = styled("div")`
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(${({ $fade }) => $fade ? 0.92 : 1});
    opacity: ${({ $fade }) => $fade ? 0 : 1};
    transition: opacity 200ms ease, transform 200ms ease;
    z-index: 9999;
  
    max-width: ${({ $maxW, $full }) => $full ? "none" : $maxW || "32rem"};
    width: ${({ $full }) => $full ? "calc(100% - 2rem)" : "auto"};
    margin: ${({ $gap }) => $gap};
    & > * {
      padding: ${({ $gap }) => $gap};
    }
  
    background: ${({ $bg }) => $bg};
    color: ${({ $text }) => $text};
    border-radius: 6px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  
    display: flex;
    flex-direction: column;
  `;
var Header = styled("header")`
    padding: 1rem 1.25rem 0.75rem;
    font-weight: 600;
    font-size: 1.125rem;
  `;
var Content = styled("section")`
    padding: 0 1.25rem 1.25rem;
    flex: 1 1 auto;
    overflow: auto;
  `;
var Actions = styled("footer")`
    padding: 0.75rem 1.25rem 1.25rem;
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
  `;
var FOCUSABLE = "button, [href], input, textarea, select, [tabindex]";
var getFocusable = (el) => el ? Array.from(el.querySelectorAll(FOCUSABLE)).filter((n) => !n.hasAttribute("disabled") && !n.getAttribute("aria-hidden")) : [];
var Modal = ({
  open: controlledOpen,
  defaultOpen = false,
  onClose,
  variant = "dialog",
  title,
  children,
  actions,
  disableBackdropClick = false,
  disableEscapeKeyDown = false,
  maxWidth,
  fullWidth = false,
  preset: presetKey
}) => {
  const { theme } = useTheme();
  const presetClasses = presetKey ? preset(presetKey) : "";
  const uncontrolled = controlledOpen === void 0;
  const [openState, setOpenState] = (0, import_react6.useState)(defaultOpen);
  const open = uncontrolled ? openState : controlledOpen;
  const [fade, setFade] = (0, import_react6.useState)(true);
  const idTitle = (0, import_react6.useId)();
  const dialogRef = (0, import_react6.useRef)(null);
  const previouslyFocused = (0, import_react6.useRef)(null);
  const requestClose = (0, import_react6.useCallback)(() => {
    if (uncontrolled) setOpenState(false);
    onClose?.();
  }, [uncontrolled, onClose]);
  (0, import_react6.useLayoutEffect)(() => {
    if (!open) return;
    setFade(false);
    previouslyFocused.current = document.activeElement;
    const el = dialogRef.current;
    if (el) {
      const focusable = getFocusable(el);
      (focusable[0] || el).focus();
    }
    const handleKeyDown = (e) => {
      if (e.key === "Escape" && !disableEscapeKeyDown) {
        e.stopPropagation();
        requestClose();
      }
      if (e.key === "Tab") {
        const nodes = getFocusable(dialogRef.current);
        if (nodes.length === 0) {
          e.preventDefault();
          return;
        }
        const first = nodes[0];
        const last = nodes[nodes.length - 1];
        if (e.shiftKey ? e.target === first : e.target === last) {
          e.preventDefault();
          (e.shiftKey ? last : first).focus();
        }
      }
    };
    document.addEventListener("keydown", handleKeyDown, true);
    return () => {
      document.removeEventListener("keydown", handleKeyDown, true);
      setFade(true);
      previouslyFocused.current?.focus?.();
    };
  }, [open, disableEscapeKeyDown, requestClose]);
  const handleBackdropClick = (e) => {
    if (disableBackdropClick) return;
    if (e.target === e.currentTarget) requestClose();
  };
  if (!open) return null;
  const modalElement = /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Backdrop, { $fade: fade, onClick: handleBackdropClick }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
      Box,
      {
        ref: dialogRef,
        role: variant === "alert" ? "alertdialog" : "dialog",
        "aria-modal": "true",
        "aria-labelledby": title ? idTitle : void 0,
        tabIndex: -1,
        $bg: theme.colors.surface,
        $text: theme.colors.text,
        $fade: fade,
        $maxW: maxWidth,
        $full: fullWidth,
        $gap: theme.spacing(1),
        className: presetClasses,
        children: [
          title && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Header, { id: idTitle, children: title }),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Content, { children }),
          actions && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Actions, { children: actions })
        ]
      }
    )
  ] });
  return (0, import_react_dom.createPortal)(modalElement, document.body);
};
var Modal_default = Modal;

// src/components/primitives/Progress.tsx
var import_react7 = require("react");
var import_jsx_runtime5 = require("react/jsx-runtime");
var geom = (_t) => ({
  circular: {
    xs: { box: "0.75rem", stroke: "0.09375rem" },
    sm: { box: "1.5rem", stroke: "0.1875rem" },
    md: { box: "2.25rem", stroke: "0.25rem" },
    lg: { box: "3rem", stroke: "0.375rem" },
    xl: { box: "3.75rem", stroke: "0.46875rem" }
  },
  linear: {
    xs: { h: "0.125rem" },
    sm: { h: "0.25rem" },
    md: { h: "0.375rem" },
    lg: { h: "0.5rem" },
    xl: { h: "0.625rem" }
  }
});
var toPx = (val) => val.endsWith("rem") ? parseFloat(val) * 16 : val.endsWith("px") ? parseFloat(val) : parseFloat(val);
var rotate360 = keyframes`
  100% { transform: rotate(360deg); }
`;
var dash = keyframes`
  0%   { stroke-dasharray: 1, 150; stroke-dashoffset: 0;   }
  50%  { stroke-dasharray: 90,150; stroke-dashoffset: -35; }
  100% { stroke-dasharray: 90,150; stroke-dashoffset: -124;}
`;
var indetBar1 = keyframes`
  0%   { left: -35%; right: 100%; }
  60%  { left: 100%; right: -90%; }
  100% { left: 100%; right: -90%; }
`;
var indetBar2 = keyframes`
  0%   { left: -200%; right: 100%; }
  60%  { left: 107%;  right: -8%;  }
  100% { left: 107%;  right: -8%;  }
`;
var Root = styled("div")`
  display: inline-block;
  position: relative;
  vertical-align: middle;
`;
var CircleWrap = styled("div")`
  width: ${({ $d }) => $d};
  height: ${({ $d }) => $d};
  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;
`;
var CenterLabel = styled("span")`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font: ${({ $font }) => $font};
  color: var(--valet-text-color, currentColor);
  user-select: none;
  pointer-events: none;
`;
var Track = styled("div")`
  width: 100%;
  height: ${({ $h }) => $h};
  background: #0003;
  border-radius: 9999px;
  overflow: hidden;
  position: relative;
`;
var Bar = styled("div")`
  position: absolute;
  top: 0;
  bottom: 0;
  background: ${({ $color }) => $color};
  transition: width 0.2s linear;
  ${({ $indet, $index }) => $indet && ($index === 1 ? `animation: ${indetBar1} 2.1s infinite ease-out;` : `animation: ${indetBar2} 2.1s infinite ease-in;`)}
`;
var Progress = (0, import_react7.forwardRef)(
  ({
    variant = "linear",
    mode = "determinate",
    value = 0,
    buffer = 0,
    size = "md",
    showLabel = false,
    color,
    preset: p,
    className,
    style,
    ...divProps
  }, ref) => {
    const { theme } = useTheme();
    const tokens = geom(theme);
    const primary = color ?? theme.colors.primary;
    const presetCls = p ? preset(p) : "";
    const mergedCls = [presetCls, className].filter(Boolean).join(" ") || void 0;
    const ariaProps = mode === "indeterminate" ? { role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100 } : {
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": Math.round(value)
    };
    if (variant === "circular") {
      let box;
      let stroke;
      if (typeof size === "number") {
        box = `${size}px`;
        stroke = `calc(${box} / 8)`;
      } else if (tokens.circular[size]) {
        ({ box, stroke } = tokens.circular[size]);
      } else {
        box = size;
        stroke = `calc(${box} / 8)`;
      }
      const boxPx = typeof size === "number" ? size : tokens.circular[size] ? toPx(tokens.circular[size].box) : toPx(size);
      const strokePx = typeof size === "number" ? boxPx / 8 : tokens.circular[size] ? toPx(tokens.circular[size].stroke) : boxPx / 8;
      const radius = (boxPx - strokePx) / 2;
      const circ = 2 * Math.PI * radius;
      const offset = (100 - value) / 100 * circ;
      const svgProps = mode === "indeterminate" ? { style: { animation: `${rotate360} 1.5s linear infinite` } } : {};
      const circleProps = mode === "indeterminate" ? {
        style: {
          strokeDasharray: "80,200",
          strokeDashoffset: 0,
          animation: `${dash} 1.5s ease-in-out infinite`
        }
      } : {
        strokeDasharray: circ,
        strokeDashoffset: offset,
        transition: "stroke-dashoffset 0.2s linear"
      };
      return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        Root,
        {
          ...divProps,
          ...ariaProps,
          ref,
          className: mergedCls,
          style,
          children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(CircleWrap, { $d: box, children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
              "svg",
              {
                width: box,
                height: box,
                viewBox: `0 0 ${boxPx} ${boxPx}`,
                ...svgProps,
                children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "circle",
                  {
                    cx: boxPx / 2,
                    cy: boxPx / 2,
                    r: radius,
                    fill: "none",
                    stroke: primary,
                    strokeWidth: strokePx,
                    strokeLinecap: "round",
                    ...circleProps
                  }
                )
              }
            ),
            showLabel && mode !== "indeterminate" && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(CenterLabel, { $font: theme.typography.body.md, children: [
              Math.round(value),
              "%"
            ] })
          ] })
        }
      );
    }
    let h;
    if (typeof size === "number") {
      h = `${size / 6}px`;
    } else if (tokens.linear[size]) {
      h = tokens.linear[size].h;
    } else {
      h = `calc(${size} / 6)`;
    }
    const barStyle = {
      width: `${value}%`,
      right: "auto",
      left: 0
    };
    const bufferStyle = {
      width: `${buffer}%`,
      right: "auto",
      left: 0,
      background: primary + "55"
    };
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      Root,
      {
        ...divProps,
        ...ariaProps,
        ref,
        className: mergedCls,
        style,
        children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(Track, { $h: h, children: [
          mode === "buffer" && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Bar, { $color: primary + "55", style: bufferStyle }),
          mode === "indeterminate" ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Bar, { $color: primary, $indet: true, $index: 1 }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Bar, { $color: primary, $indet: true, $index: 2 })
          ] }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(Bar, { $color: primary, style: barStyle })
        ] })
      }
    );
  }
);
Progress.displayName = "Progress";

// src/components/primitives/Video.tsx
var import_react8 = require("react");
var import_jsx_runtime6 = require("react/jsx-runtime");
var VideoWrapper = styled("div")`
  position: relative;
  width: ${({ $w }) => $w || "100%"};
  height: ${({ $h }) => $h || "auto"};
  overflow: hidden;

  video {
    width: 100%;
    height: 100%;
    object-fit: ${({ $fit }) => $fit};
  }
`;
var Video = ({
  sources,
  poster,
  tracks,
  controls = true,
  autoPlay = true,
  muted = true,
  loop = false,
  width,
  height,
  lazy,
  objectFit = "contain",
  onPlay,
  onPause,
  onLoop,
  onError,
  className,
  style,
  preset: p
}) => {
  const ref = (0, import_react8.useRef)(null);
  const [ready, setReady] = (0, import_react8.useState)(!lazy);
  (0, import_react8.useEffect)(() => {
    if (!lazy || ready || !("IntersectionObserver" in window)) return;
    const vid = ref.current;
    if (!vid) return;
    const io = new IntersectionObserver(([e]) => {
      if (e.isIntersecting) setReady(true);
    }, { threshold: 0.1 });
    io.observe(vid);
    return () => io.disconnect();
  }, [lazy, ready]);
  (0, import_react8.useEffect)(() => {
    const vid = ref.current;
    if (!vid || !loop) return;
    const handler = () => onLoop?.();
    vid.addEventListener("ended", handler);
    return () => vid.removeEventListener("ended", handler);
  }, [loop, onLoop]);
  const togglePlay = () => {
    const vid = ref.current;
    if (!vid) return;
    if (vid.paused) vid.play().catch(() => void 0);
    else vid.pause();
  };
  const handleKey = (e) => {
    if (e.code === "Space" || e.code === "Enter") {
      e.preventDefault();
      togglePlay();
    }
    if (e.key.toLowerCase() === "c") {
      const t = ref.current?.textTracks[0];
      if (t) t.mode = t.mode === "showing" ? "disabled" : "showing";
    }
  };
  const presetCls = p ? preset(p) : "";
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    VideoWrapper,
    {
      $w: width,
      $h: height,
      $fit: objectFit,
      className: [presetCls, className].filter(Boolean).join(" "),
      style,
      children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
        "video",
        {
          ref,
          controls,
          autoPlay: autoPlay && ready,
          muted,
          loop,
          playsInline: true,
          preload: "metadata",
          poster,
          tabIndex: 0,
          onPlay,
          onPause,
          onError: (e) => onError?.(e),
          onKeyDown: handleKey,
          children: [
            ready && sources.map((s, i) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("source", { src: s.src, type: s.type }, i)),
            ready && tracks?.map((t, i) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("track", { ...t }, i))
          ]
        }
      )
    }
  );
};

// src/components/primitives/Image.tsx
var import_react9 = require("react");
var import_jsx_runtime7 = require("react/jsx-runtime");
var Img2 = styled("img")`
  display: block;
  width: ${({ $w }) => $w || "auto"};
  height: ${({ $h }) => $h || "auto"};
  object-fit: ${({ $fit }) => $fit};
  border-radius: ${({ $radius }) => $radius || 0};
`;
var Image2 = ({
  src,
  width,
  height,
  objectFit = "cover",
  rounded,
  lazy = false,
  placeholder,
  preset: p,
  className,
  style,
  ...rest
}) => {
  const [ready, setReady] = (0, import_react9.useState)(!lazy);
  const ref = (0, import_react9.useRef)(null);
  (0, import_react9.useEffect)(() => {
    if (!lazy || ready || !("IntersectionObserver" in window)) return;
    const img = ref.current;
    if (!img) return;
    const io = new IntersectionObserver(([e]) => {
      if (e.isIntersecting) setReady(true);
    }, { threshold: 0.1 });
    io.observe(img);
    return () => io.disconnect();
  }, [lazy, ready]);
  const presetCls = p ? preset(p) : "";
  const w = typeof width === "number" ? `${width}px` : width;
  const h = typeof height === "number" ? `${height}px` : height;
  const r = typeof rounded === "number" ? `${rounded}px` : rounded;
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    Img2,
    {
      ...rest,
      ref,
      src: ready ? src : placeholder,
      $w: w,
      $h: h,
      $fit: objectFit,
      $radius: r,
      loading: lazy ? "lazy" : rest.loading,
      className: [presetCls, className].filter(Boolean).join(" "),
      style
    }
  );
};
var Image_default = Image2;

// src/components/layout/Grid.tsx
var import_shallow2 = require("zustand/shallow");
var import_jsx_runtime8 = require("react/jsx-runtime");
var Root2 = styled("div")`
  display: grid;
  grid-template-columns: repeat(${({ $cols }) => $cols}, 1fr);
  gap: ${({ $gap }) => $gap};
  margin: ${({ $pad }) => $pad};
  & > * {
    padding: ${({ $pad }) => $pad};
  }
`;
var Grid = ({
  columns = 2,
  gap = 2,
  adaptive = false,
  preset: p,
  style,
  className,
  children,
  ...rest
}) => {
  const { theme } = useTheme();
  const { width, height } = useSurface(
    (s) => ({ width: s.width, height: s.height }),
    import_shallow2.shallow
  );
  const portrait = height > width;
  const effectiveCols = adaptive && portrait ? 1 : columns;
  let g;
  if (typeof gap === "number") {
    g = theme.spacing(gap);
  } else {
    g = String(gap);
  }
  const pad = theme.spacing(1);
  const presetClass = p ? preset(p) : "";
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    Root2,
    {
      ...rest,
      $cols: effectiveCols,
      $gap: g,
      $pad: pad,
      style,
      className: [presetClass, className].filter(Boolean).join(" "),
      children
    }
  );
};
var Grid_default = Grid;

// src/components/layout/Stack.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
var StackContainer = styled("div")`
  display: flex;
  flex-direction: ${({ $dir }) => $dir};
  align-items: ${({ $dir }) => $dir === "row" ? "center" : "stretch"};
  gap: ${({ $gap }) => $gap};
  ${({ $wrap }) => $wrap ? "flex-wrap: wrap;" : ""};

  /* Boundary guards */
  max-width: 100%;
  max-height: 100%;
  min-width: 0;
  min-height: 0;

  /* No horizontal scrolling, vertical allowed */
  overflow-x: hidden;
  overflow-y: auto;

  /* Hide native scrollbars where supported */
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE & Edge */
  &::-webkit-scrollbar { display: none; }

  box-sizing: border-box;

  margin: ${({ $margin }) => $margin};
  & > * {
    margin: ${({ $pad }) => $pad};
  }
`;
var Stack = ({
  direction = "column",
  spacing,
  wrap,
  compact,
  preset: p,
  className,
  children,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  let gap;
  let gapInput = spacing;
  if (gapInput === void 0) {
    gapInput = compact ? 0 : 1;
  }
  gap = typeof gapInput === "number" ? theme.spacing(gapInput) : String(gapInput);
  const shouldWrap = typeof wrap === "boolean" ? wrap : direction === "row";
  const presetClasses = p ? preset(p) : "";
  const pad = theme.spacing(1);
  const margin = compact ? "0" : pad;
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    StackContainer,
    {
      ...rest,
      $dir: direction,
      $gap: gap,
      $wrap: shouldWrap,
      $margin: margin,
      $pad: pad,
      className: [presetClasses, className].filter(Boolean).join(" "),
      style,
      children
    }
  );
};
var Stack_default = Stack;

// src/components/layout/Surface.tsx
var import_react10 = require("react");

// src/system/fontStore.ts
var import_traditional3 = require("zustand/traditional");
var useFonts = (0, import_traditional3.createWithEqualityFn)((set) => ({
  loading: 0,
  ready: false,
  start: () => set((s) => ({ loading: s.loading + 1, ready: false })),
  finish: () => set((s) => {
    const loading = Math.max(0, s.loading - 1);
    return { loading, ready: loading === 0 };
  })
}));

// src/components/widgets/LoadingBackdrop.tsx
var import_jsx_runtime10 = require("react/jsx-runtime");
var LoadingBackdrop = ({
  fading,
  showSpinner
}) => {
  const { theme } = useTheme();
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    "div",
    {
      style: {
        position: "fixed",
        inset: 0,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: theme.colors.background,
        color: theme.colors.text,
        zIndex: 9999,
        transition: "opacity 200ms ease",
        opacity: fading ? 0 : 1
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
        "div",
        {
          style: {
            transition: "opacity 200ms ease",
            opacity: showSpinner ? 1 : 0
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Progress, { variant: "circular", mode: "indeterminate" })
        }
      )
    }
  );
};
var LoadingBackdrop_default = LoadingBackdrop;

// src/components/layout/Surface.tsx
var import_jsx_runtime11 = require("react/jsx-runtime");
var Surface = ({
  children,
  style,
  preset: p,
  className,
  fullscreen = true,
  ...props
}) => {
  const parent = (0, import_react10.useContext)(SurfaceCtx);
  if (parent) throw new Error("Nested <Surface> components are not allowed");
  const storeRef = (0, import_react10.useRef)(null);
  if (!storeRef.current) storeRef.current = createSurfaceStore();
  const useStore = storeRef.current;
  const ref = (0, import_react10.useRef)(null);
  const { theme } = useTheme();
  const fontsReady = useFonts((s) => s.ready);
  const [showBackdrop, setShowBackdrop] = (0, import_react10.useState)(!fontsReady);
  const [fade, setFade] = (0, import_react10.useState)(false);
  const [showSpinner, setShowSpinner] = (0, import_react10.useState)(false);
  const presetClasses = p ? preset(p) : "";
  const { width, height } = useStore((s) => ({
    width: s.width,
    height: s.height
  }));
  const bpFor = (w) => Object.entries(theme.breakpoints).reduce(
    (acc, [key, min]) => w >= min ? key : acc,
    "xs"
  );
  (0, import_react10.useEffect)(() => {
    const node = ref.current;
    if (!node) return;
    useStore.setState((s) => ({ ...s, element: node }));
    const measure = () => {
      const rect = node.getBoundingClientRect();
      useStore.setState((s) => ({
        ...s,
        width: rect.width,
        height: Math.round(rect.height),
        breakpoint: bpFor(rect.width)
      }));
    };
    const ro = new ResizeObserver(measure);
    const mo = new MutationObserver(measure);
    ro.observe(node);
    mo.observe(node, { childList: true, subtree: true });
    measure();
    return () => {
      ro.disconnect();
      mo.disconnect();
    };
  }, [theme.breakpoints, useStore]);
  (0, import_react10.useEffect)(() => {
    if (!fontsReady) {
      setShowBackdrop(true);
      setFade(false);
      setShowSpinner(false);
      return;
    }
    setFade(true);
    const t = setTimeout(() => setShowBackdrop(false), 200);
    setShowSpinner(false);
    return () => clearTimeout(t);
  }, [fontsReady]);
  (0, import_react10.useEffect)(() => {
    if (fontsReady) {
      setShowSpinner(false);
      return;
    }
    const t = setTimeout(() => {
      if (!useFonts.getState().ready) setShowSpinner(true);
    }, 1250);
    return () => clearTimeout(t);
  }, [fontsReady]);
  const defaults = {
    background: theme.colors.background,
    color: theme.colors.text
  };
  const cssVars = {
    "--valet-bg": theme.colors.background,
    "--valet-text-color": theme.colors.text,
    "--valet-font-heading": theme.fonts.heading,
    "--valet-font-body": theme.fonts.body,
    "--valet-font-mono": theme.fonts.mono,
    "--valet-font-button": theme.fonts.button
  };
  const layoutStyles = fullscreen ? {
    position: "fixed",
    inset: 0,
    paddingTop: "env(safe-area-inset-top)",
    paddingRight: "env(safe-area-inset-right)",
    paddingBottom: "env(safe-area-inset-bottom)",
    paddingLeft: "env(safe-area-inset-left)",
    overflow: "auto"
    // ← never show scrollbars on a surface
  } : {
    position: "relative",
    width: "100%",
    height: "auto",
    overflow: "auto"
  };
  const gap = theme.spacing(1);
  return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(SurfaceCtx.Provider, { value: useStore, children: /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(
    "div",
    {
      ref,
      ...props,
      className: [presetClasses, className].filter(Boolean).join(" "),
      style: {
        ...layoutStyles,
        ...defaults,
        ...cssVars,
        "--valet-screen-width": `${width}px`,
        "--valet-screen-height": `${Math.round(height)}px`,
        ...style
      },
      children: [
        showBackdrop && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(LoadingBackdrop_default, { fading: fade, showSpinner }),
        /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
          "div",
          {
            style: {
              visibility: fontsReady ? "visible" : "hidden",
              padding: gap,
              maxWidth: "100%",
              maxHeight: "100%",
              boxSizing: "border-box"
            },
            children
          }
        )
      ]
    }
  ) });
};

// src/components/layout/Box.tsx
var import_jsx_runtime12 = require("react/jsx-runtime");
var Base = styled("div")`
  box-sizing: border-box;

  /* Boundary & overflow guards */
  max-width  : 100%;
  max-height : 100%;
  min-width  : 0;
  min-height : 0;
  overflow   : hidden;

  display: ${({ $center }) => $center ? "flex" : "block"};
  margin : ${({ $margin }) => $margin};
  & > * {
    padding: ${({ $pad }) => $pad};
  }

  ${({ $center }) => $center && `
      justify-content: center;
      align-items: center;
    `}

  ${({ $bg }) => $bg && `background: ${$bg}; --valet-bg: ${$bg};`}  
  ${({ $text }) => $text && `color: ${$text}; --valet-text-color: ${$text};`}
  ${({ $center }) => $center !== void 0 && `--valet-centered: ${$center ? "1" : "0"};`}
`;
var Box2 = ({
  preset: p,
  className,
  background,
  textColor,
  centered,
  compact,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  const presetClass = p ? preset(p) : "";
  let resolvedText = textColor;
  if (!resolvedText && background) {
    resolvedText = background === theme.colors.primary ? theme.colors.primaryText : background === theme.colors.secondary ? theme.colors.secondaryText : background === theme.colors.tertiary ? theme.colors.tertiaryText : void 0;
  }
  const pad = theme.spacing(1);
  const margin = compact ? "0" : pad;
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
    Base,
    {
      ...rest,
      $bg: background,
      $text: resolvedText,
      $center: centered,
      $margin: margin,
      $pad: pad,
      style,
      className: [presetClass, className].filter(Boolean).join(" ")
    }
  );
};

// src/components/layout/Panel.tsx
var import_jsx_runtime13 = require("react/jsx-runtime");
var Base2 = styled("div")`
  box-sizing: border-box;
  vertical-align: top;

  display      : ${({ $center, $full }) => $center ? "flex" : $full ? "block" : "inline-block"};
  width        : ${({ $full }) => $full ? "100%" : "auto"};
  align-self   : ${({ $full }) => $full ? "stretch" : "flex-start"};

  /* Boundary guards */
  max-width  : 100%;
  max-height : 100%;
  min-width  : 0;
  min-height : 0;

  /* Prevent horizontal scrolling */
  overflow-x: hidden;
  overflow-y: auto;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE & Edge */
  &::-webkit-scrollbar { display: none; }

  margin       : ${({ $margin }) => $margin};
  & > * {
    padding: ${({ $pad }) => $pad};
  }

  ${({ $center }) => $center && `
      justify-content: center;
      align-items: center;
    `}

  /* Background handling ------------------------------------- */
  ${({ $variant, $bg }) => $bg && `
      background: ${$variant === "main" ? $bg : "transparent"};
      --valet-bg: ${$bg};
    `}

  /* Variant “alt” gets outline ------------------------------ */
  ${({ $variant, $outline }) => $variant === "alt" && $outline ? `border: 1px solid ${$outline};` : ""}

  ${({ $text }) => $text && `
      color: ${$text};
      --valet-text-color: ${$text};
    `}

  ${({ $center }) => $center !== void 0 && `--valet-centered: ${$center ? "1" : "0"};`}
`;
var Panel = ({
  variant = "main",
  fullWidth = false,
  centered,
  preset: p,
  className,
  style,
  background,
  compact,
  children,
  ...rest
}) => {
  const { theme } = useTheme();
  const hasBgProp = typeof background === "string";
  const hasPresetBg = p ? presetHas(p, "background") : false;
  const bg = hasBgProp ? background : !hasPresetBg && variant === "main" ? theme.colors.backgroundAlt : void 0;
  let textColour;
  if (bg) {
    textColour = bg === theme.colors.primary ? theme.colors.primaryText : bg === theme.colors.secondary ? theme.colors.secondaryText : bg === theme.colors.tertiary ? theme.colors.tertiaryText : theme.colors.text;
  }
  const pad = theme.spacing(1);
  const margin = compact ? "0" : pad;
  const presetClasses = p ? preset(p) : "";
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
    Base2,
    {
      ...rest,
      $variant: variant,
      $full: fullWidth,
      $center: centered,
      $outline: theme.colors.backgroundAlt,
      $bg: bg,
      $text: textColour,
      $margin: margin,
      $pad: pad,
      style,
      className: [presetClasses, className].filter(Boolean).join(" "),
      children
    }
  );
};
var Panel_default = Panel;

// src/components/fields/Button.tsx
var import_react11 = __toESM(require("react"));
var import_jsx_runtime14 = require("react/jsx-runtime");
var createSizeMap = (t) => ({
  xs: { padV: t.spacing(1), padH: t.spacing(1), font: "1rem", height: "1.5rem" },
  sm: { padV: t.spacing(1), padH: t.spacing(1), font: "1rem", height: "2rem" },
  md: { padV: t.spacing(1), padH: t.spacing(1), font: "1rem", height: "2.5rem" },
  lg: { padV: t.spacing(1), padH: t.spacing(1), font: "1rem", height: "3rem" },
  xl: { padV: t.spacing(1), padH: t.spacing(1), font: "1rem", height: "3.5rem" }
});
var Root3 = styled("button")`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;

  height   : ${({ $height }) => $height};
  min-width: ${({ $minW }) => $minW};
  padding  : ${({ $padRule }) => $padRule};
  box-sizing: border-box;

  align-self: ${({ $full }) => $full ? "stretch" : "flex-start"};
  width     : ${({ $full }) => $full ? "100%" : "auto"};

  border-radius: 4px;
  border: ${({ $variant, $outline }) => $variant === "outlined" ? `1px solid ${$outline}` : "none"};

  background: ${({ $variant, $bg }) => $variant === "contained" ? $bg : "transparent"};

  color      : ${({ $label }) => $label};
  font-size  : ${({ $font }) => $font};
  font-weight: 600;
  line-height: 1;
  cursor     : pointer;
  transition :
    background 0.2s ease,
    color      0.2s ease,
    transform  0.1s ease,
    filter     0.2s ease;

  -webkit-tap-highlight-color: transparent;

  @media (hover: hover) {
    &:hover:not(:disabled) {
      ${({ $variant, $bg, $hoverLabel }) => $variant === "contained" ? "filter: brightness(1.25);" : `
            background: ${$bg};
            color: ${$hoverLabel};
          `}
    }
  }

  &:active:not(:disabled) { transform: scale(0.96); }
  &:disabled              { opacity: 0.5; cursor: default; }

  &::after {
    content : '';
    position: absolute;
    inset   : 0;
    background    : ${({ $ripple }) => $ripple};
    border-radius : inherit;
    transform     : scale(0.95);
    opacity       : 0;
    pointer-events: none;
    transition    : transform 0.3s ease, opacity 0.3s ease;
  }
  &:active:not(:disabled)::after {
    opacity: 1;
    transform: scale(1);
  }
`;
var Button = ({
  variant = "contained",
  size = "md",
  color,
  textColor,
  fullWidth = false,
  preset: p,
  className,
  children,
  ...rest
}) => {
  const { theme, mode } = useTheme();
  const map = createSizeMap(theme);
  let geom4;
  if (typeof size === "number") {
    const h = `${size}px`;
    geom4 = { padV: theme.spacing(1), padH: theme.spacing(1), font: "1rem", height: h };
  } else if (map[size]) {
    geom4 = map[size];
  } else {
    geom4 = { padV: theme.spacing(1), padH: theme.spacing(1), font: "1rem", height: size };
  }
  const { padV, padH, font, height } = geom4;
  const padRule = variant === "outlined" ? `calc(${padV} - 1px) calc(${padH} - 1px)` : `${padV} ${padH}`;
  const minW = `calc(${height} * 2)`;
  const isToken = (v) => v === "primary" || v === "secondary" || v === "tertiary";
  const paletteToken = color === void 0 ? "primary" : isToken(color) ? color : null;
  const bg = paletteToken ? theme.colors[paletteToken] : color ? isToken(color) ? theme.colors[color] : color : theme.colors.primary;
  const outlineNeutral = mode === "dark" ? "#eee" : "#111";
  const resolveText = (v) => isToken(v) ? theme.colors[`${v}Text`] : v;
  let labelColor;
  if (variant === "outlined") {
    labelColor = textColor ? resolveText(textColor) : outlineNeutral;
  } else {
    labelColor = textColor ? resolveText(textColor) : paletteToken ? theme.colors[`${paletteToken}ButtonText`] : theme.colors.text;
  }
  const hoverLabel = variant === "outlined" ? textColor ? resolveText(textColor) : paletteToken ? theme.colors[`${paletteToken}ButtonText`] : "#fff" : labelColor;
  const ripple = variant === "contained" ? "rgba(255,255,255,0.25)" : paletteToken ? `${theme.colors[paletteToken]}33` : "rgba(0,0,0,0.1)";
  const presetClasses = p ? preset(p) : "";
  const childArray = import_react11.default.Children.toArray(children);
  const grouped = [];
  let buffer = "";
  childArray.forEach((node, i) => {
    if (typeof node === "string" || typeof node === "number") {
      buffer += node;
    } else {
      if (buffer) {
        grouped.push(
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            Typography,
            {
              variant: "button",
              bold: true,
              fontSize: font,
              noSelect: true,
              children: buffer
            },
            `text-${i}`
          )
        );
        buffer = "";
      }
      grouped.push(node);
    }
  });
  if (buffer) {
    grouped.push(
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        Typography,
        {
          variant: "button",
          bold: true,
          fontSize: font,
          noSelect: true,
          children: buffer
        },
        "text-final"
      )
    );
  }
  const content = grouped;
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
    Root3,
    {
      ...rest,
      style: { "--valet-text-color": labelColor },
      className: [presetClasses, className].filter(Boolean).join(" "),
      $variant: variant,
      $height: height,
      $padRule: padRule,
      $font: font,
      $minW: minW,
      $bg: bg,
      $label: labelColor,
      $hoverLabel: hoverLabel,
      $outline: outlineNeutral,
      $ripple: ripple,
      $full: fullWidth,
      children: content
    }
  );
};
var Button_default = Button;

// src/components/fields/Checkbox.tsx
var import_react13 = require("react");

// src/components/fields/FormControl.tsx
var import_react12 = require("react");
var import_jsx_runtime15 = require("react/jsx-runtime");
var FormCtx = (0, import_react12.createContext)(null);
var useForm = () => {
  const ctx = (0, import_react12.useContext)(FormCtx);
  if (!ctx)
    throw new Error("useForm must be used inside a <FormControl> component");
  return ctx;
};
function FormControl({
  useStore,
  onSubmitValues,
  preset: p,
  className,
  children,
  ...rest
}) {
  const store = useStore();
  const presetClasses = p ? preset(p) : "";
  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmitValues?.(store.values, e);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(FormCtx.Provider, { value: store, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
    "form",
    {
      ...rest,
      onSubmit: handleSubmit,
      className: [presetClasses, className].filter(Boolean).join(" "),
      children
    }
  ) });
}

// src/helpers/color.ts
var rgbCache = /* @__PURE__ */ new Map();
function toRgb(hex) {
  if (rgbCache.has(hex)) return rgbCache.get(hex);
  let s = hex.startsWith("#") ? hex.slice(1) : hex;
  if (s.length === 3) s = s.replace(/./g, (ch) => ch + ch);
  let rgb;
  if (s.length === 6 && !/[^a-f\d]/i.test(s)) {
    const n = parseInt(s, 16);
    rgb = { r: n >> 16 & 255, g: n >> 8 & 255, b: n & 255 };
  } else {
    rgb = { r: 0, g: 0, b: 0 };
  }
  rgbCache.set(hex, rgb);
  return rgb;
}
function mix(a, b, weight) {
  const t = weight <= 0 ? 0 : weight >= 1 ? 1 : weight;
  return {
    r: a.r * (1 - t) + b.r * t + 0.5 | 0,
    g: a.g * (1 - t) + b.g * t + 0.5 | 0,
    b: a.b * (1 - t) + b.b * t + 0.5 | 0
  };
}
function toHex({ r, g, b }) {
  return "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
}
function withAlpha(hex, alpha) {
  const { r, g, b } = toRgb(hex);
  const a = alpha <= 0 ? 0 : alpha >= 1 ? 1 : alpha;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
var stripeCache = /* @__PURE__ */ new Map();
function stripe(bgHex, textHex) {
  const key = `${bgHex}|${textHex}`;
  if (stripeCache.has(key)) return stripeCache.get(key);
  const result = toHex(mix(toRgb(bgHex), toRgb(textHex), 0.1));
  stripeCache.set(key, result);
  return result;
}

// src/components/fields/Checkbox.tsx
var import_jsx_runtime16 = require("react/jsx-runtime");
var createSizeMap2 = (t) => ({
  xs: { box: "0.75rem", tick: "calc(0.75rem * 0.6)", gap: t.spacing(1) },
  sm: { box: "1rem", tick: "calc(1rem * 0.6)", gap: t.spacing(1) },
  md: { box: "1.25rem", tick: "calc(1.25rem * 0.6)", gap: t.spacing(1) },
  lg: { box: "1.5rem", tick: "calc(1.5rem * 0.6)", gap: t.spacing(1) },
  xl: { box: "1.75rem", tick: "calc(1.75rem * 0.6)", gap: t.spacing(1) }
});
var Wrapper2 = styled("label")`
  display: inline-flex;
  align-items: center;
  gap: var(--checkbox-gap);
  cursor: ${({ $disabled }) => $disabled ? "not-allowed" : "pointer"};
  user-select: none;
  color: ${({ $disabled, $disabledColor }) => $disabled ? $disabledColor : "inherit"};

  /* Prevent blue flash on mobile */
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
`;
var HiddenInput = styled("input")`
  position: absolute;
  opacity: 0;
  pointer-events: none;
  width: 0;
  height: 0;
`;
var Box3 = styled("span")`
  position: relative;
  display: inline-block;
  width:  ${({ $size }) => $size};
  height: ${({ $size }) => $size};
  min-width: ${({ $size }) => $size};
  border-radius: 4px;
  box-sizing: border-box;

  /* Outline always visible, greyed when disabled */
  border: 2px solid
    ${({ $disabled, $disabledColor, $text }) => $disabled ? $disabledColor : $text};

  /* Fill when checked, swap to disabled colour if disabled */
  background: ${({ $checked, $disabled, $primary, $disabledColor }) => $checked ? $disabled ? $disabledColor : $primary : "transparent"};

  transition: background 120ms ease, border-color 120ms ease;

  /* Remove tap highlight */
  -webkit-tap-highlight-color: transparent;

  @media (hover: hover) {
    &:hover {
      ${({ $disabled }) => $disabled ? "" : "filter: brightness(1.25);"}
    }
  }

  &::after {
    content: '';
    position: absolute;
    inset: 0;
    display: block;
    width: ${({ $size }) => `calc(${$size} - 4px)`};
    height: ${({ $size }) => `calc(${$size} - 4px)`};
    margin: auto;
    opacity: ${({ $checked }) => $checked ? 1 : 0};
    transform: ${({ $checked }) => $checked ? "scale(1)" : "scale(0.85)"};
    background: url("data:image/svg+xml,%3Csvg viewBox='0 0 24 24' " +
                    "xmlns='http://www.w3.org/2000/svg' "          +
                    "fill='none' stroke='%23fff' stroke-width='3' " +
                    "stroke-linecap='round' stroke-linejoin='round'%3E" +
                    "%3Cpolyline points='20 6 9 17 4 12'/%3E%3C/svg%3E")
               center/contain no-repeat;
    transition: opacity 120ms ease, transform 120ms ease;
    /* Fade tick when disabled */
    filter: ${({ $disabled }) => $disabled ? "grayscale(1)" : "none"};
  }
`;
var Checkbox = (0, import_react13.forwardRef)(
  ({
    name,
    checked: checkedProp,
    defaultChecked,
    label,
    size = "md",
    disabled = false,
    onChange,
    preset: presetKey,
    className,
    style,
    children,
    ...inputRest
  }, ref) => {
    const { theme, mode } = useTheme();
    const map = createSizeMap2(theme);
    let SZ;
    if (typeof size === "number") {
      const box = `${size}px`;
      SZ = { box, tick: `calc(${box} * 0.6)`, gap: theme.spacing(1) };
    } else if (map[size]) {
      SZ = map[size];
    } else {
      SZ = { box: size, tick: `calc(${size} * 0.6)`, gap: theme.spacing(1) };
    }
    const disabledColor = toHex(
      mix(
        toRgb(theme.colors.text),
        toRgb(mode === "dark" ? "#000" : "#fff"),
        0.4
      )
    );
    let form = null;
    try {
      form = useForm();
    } catch {
    }
    const controlled = checkedProp !== void 0;
    const formBound = Boolean(form);
    const initialState = controlled ? checkedProp : formBound ? Boolean(form.values[name]) : Boolean(defaultChecked);
    const [internal, setInternal] = (0, import_react13.useState)(initialState);
    const currentChecked = controlled ? checkedProp : formBound ? Boolean(form.values[name]) : internal;
    const handleChange = (0, import_react13.useCallback)(
      (e) => {
        const next = e.target.checked;
        if (!controlled && !formBound) setInternal(next);
        form?.setField(name, next);
        onChange?.(next, e);
      },
      [controlled, formBound, form, name, onChange]
    );
    const id = (0, import_react13.useId)();
    const presetCls = presetKey ? preset(presetKey) : "";
    const mergedCls = [presetCls, className].filter(Boolean).join(" ") || void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(
      Wrapper2,
      {
        htmlFor: id,
        style: { "--checkbox-gap": SZ.gap, ...style },
        className: mergedCls,
        $disabled: disabled,
        $disabledColor: disabledColor,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
            HiddenInput,
            {
              ...inputRest,
              id,
              ref,
              name,
              type: "checkbox",
              disabled,
              checked: currentChecked,
              onChange: handleChange
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
            Box3,
            {
              $size: SZ.box,
              $checked: currentChecked,
              $primary: theme.colors.secondary,
              $text: theme.colors.text,
              $disabled: disabled,
              $disabledColor: disabledColor,
              "aria-hidden": true
            }
          ),
          label ?? children
        ]
      }
    );
  }
);
Checkbox.displayName = "Checkbox";

// src/components/fields/IconButton.tsx
var import_jsx_runtime17 = require("react/jsx-runtime");
var geom2 = () => ({
  xs: { d: "1.5rem", icon: "0.75rem" },
  sm: { d: "2rem", icon: "1rem" },
  md: { d: "3rem", icon: "1.5rem" },
  lg: { d: "4rem", icon: "2rem" },
  xl: { d: "5rem", icon: "2.5rem" }
});
var Skin = styled("button")`
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
  box-sizing: border-box;

  border: ${({ $variant, $text }) => $variant === "outlined" ? `1px solid ${$text}` : "none"};

  background: ${({ $variant, $primary }) => $variant === "contained" ? $primary : "transparent"};

  color: ${({ $variant, $text, $primaryText }) => $variant === "contained" ? $primaryText : $text};

  cursor: pointer;
  transition:
    background 0.2s ease,
    color      0.2s ease,
    filter     0.2s ease,
    transform  0.1s ease;

  user-select: none;

  &:hover:not(:disabled) {
    ${({ $variant, $primary, $primaryText }) => $variant === "contained" ? "filter: brightness(1.25);" : `
          background: ${$primary};
          color: ${$primaryText};
        `}
  }

  &:active:not(:disabled)   { transform: scale(0.94); }
  &:disabled                { opacity: 0.5; cursor: default; }

  /* ripple -------------------------------------------------------------- */
  &::after {
    content: '';
    position: absolute;
    inset: 0;
    background: ${({ $ripple }) => $ripple};
    border-radius: 50%;
    opacity: 0;
    transform: scale(0.8);
    pointer-events: none;
    transition: transform 0.3s ease, opacity 0.3s ease;
  }
  &:active:not(:disabled)::after { opacity: 1; transform: scale(1); }
`;
var IconButton = ({
  variant = "contained",
  size = "md",
  icon,
  svg,
  iconColor,
  preset: p,
  className,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  const sizes = geom2(theme);
  let diam;
  let iconSz;
  if (typeof size === "number") {
    diam = `${size}px`;
    iconSz = `calc(${diam} * 0.45)`;
  } else if (sizes[size]) {
    ({ d: diam, icon: iconSz } = sizes[size]);
  } else {
    diam = size;
    iconSz = `calc(${diam} * 0.45)`;
  }
  const ripple = variant === "contained" ? "rgba(255,255,255,0.25)" : "rgba(0,0,0,0.1)";
  const presetClasses = p ? preset(p) : "";
  const geomStyle = {
    width: diam,
    height: diam,
    minWidth: diam,
    minHeight: diam,
    borderRadius: "50%"
  };
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    Skin,
    {
      type: "button",
      ...rest,
      onContextMenu: (e) => e.preventDefault(),
      $variant: variant,
      $primary: theme.colors.primary,
      $text: theme.colors.text,
      $primaryText: theme.colors.primaryText,
      $ripple: ripple,
      style: { ...geomStyle, ...style },
      className: [presetClasses, className].filter(Boolean).join(" "),
      children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
        Icon,
        {
          icon,
          svg,
          size: iconSz,
          color: iconColor,
          "aria-hidden": rest["aria-label"] ? void 0 : true
        }
      )
    }
  );
};
var IconButton_default = IconButton;

// src/components/fields/RadioGroup.tsx
var import_react14 = require("react");
var import_jsx_runtime18 = require("react/jsx-runtime");
var RadioGroupCtx = (0, import_react14.createContext)(null);
var useRadioGroup = () => {
  const ctx = (0, import_react14.useContext)(RadioGroupCtx);
  if (!ctx) throw new Error("Radio must be used within a <RadioGroup>.");
  return ctx;
};
var createSizeMap3 = (t) => ({
  xs: { indicator: "0.75rem", dot: "calc(0.75rem * 0.6)", gapInner: t.spacing(0.75) },
  sm: { indicator: "1rem", dot: "calc(1rem * 0.6)", gapInner: t.spacing(0.75) },
  md: { indicator: "1.25rem", dot: "calc(1.25rem * 0.6)", gapInner: t.spacing(0.75) },
  lg: { indicator: "1.5rem", dot: "calc(1.5rem * 0.6)", gapInner: t.spacing(1) },
  xl: { indicator: "1.75rem", dot: "calc(1.75rem * 0.6)", gapInner: t.spacing(1) }
});
var RootBase = styled("div")`
  display: flex; /* direction + gap inline */
`;
var OptionLabel = styled("label")`
  display: inline-flex;
  align-items: center;
  cursor: ${({ $disabled }) => $disabled ? "not-allowed" : "pointer"};
  user-select: none;
  color: ${({ $disabled, $disabledColor }) => $disabled ? $disabledColor : "inherit"};

  /* Mobile tap highlight suppression */
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
`;
var HiddenInput2 = styled("input")`
  position: absolute;
  opacity : 0;
  width   : 0;
  height  : 0;
  pointer-events: none;
`;
var RadioGroup = ({
  value: valueProp,
  defaultValue,
  name: nameProp,
  row = false,
  size = "md",
  spacing,
  onChange,
  preset: p,
  style,
  className,
  children,
  ...rest
}) => {
  const { theme } = useTheme();
  const id = (0, import_react14.useId)();
  const name = nameProp ?? `radio-group-${id}`;
  const controlled = valueProp !== void 0;
  const [selfVal, setSelfVal] = (0, import_react14.useState)(defaultValue ?? null);
  const setValue = (0, import_react14.useCallback)(
    (v) => {
      if (!controlled) setSelfVal(v);
      onChange?.(v);
    },
    [controlled, onChange]
  );
  const ctxVal = (0, import_react14.useMemo)(
    () => ({
      value: controlled ? valueProp ?? null : selfVal,
      setValue,
      name,
      size
    }),
    [controlled, valueProp, selfVal, name, size, setValue]
  );
  let gapCss;
  if (spacing === void 0) {
    gapCss = row ? theme.spacing(1) : theme.spacing(1.5);
  } else if (typeof spacing === "number") {
    gapCss = theme.spacing(spacing);
  } else {
    gapCss = String(spacing);
  }
  const ref = (0, import_react14.useRef)(null);
  const onKey = (e) => {
    if (!["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp"].includes(e.key))
      return;
    e.preventDefault();
    const radios = ref.current?.querySelectorAll(
      'input[type="radio"]:not([disabled])'
    );
    if (!radios?.length) return;
    const idx = Array.from(radios).findIndex((r) => r === document.activeElement);
    const step = e.key === "ArrowRight" || e.key === "ArrowDown" ? 1 : -1;
    const next = (idx + step + radios.length) % radios.length;
    radios[next]?.focus();
    radios[next]?.click();
  };
  const presetCls = p ? preset(p) : "";
  const mergedCls = [presetCls, className].filter(Boolean).join(" ") || void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(RadioGroupCtx.Provider, { value: ctxVal, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
    RootBase,
    {
      ...rest,
      ref,
      role: "radiogroup",
      onKeyDown: onKey,
      className: mergedCls,
      style: {
        flexDirection: row ? "row" : "column",
        alignItems: row ? "center" : "flex-start",
        gap: gapCss,
        ...style
      },
      children
    }
  ) });
};
var Indicator = ({
  checked,
  outerSize,
  dotSize,
  primary,
  disabled,
  disabledColor,
  ...rest
}) => {
  const ring = disabled ? disabledColor : primary;
  return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
    "span",
    {
      ...rest,
      "aria-hidden": true,
      style: {
        width: outerSize,
        height: outerSize,
        minWidth: outerSize,
        borderRadius: "50%",
        border: `2px solid ${ring}`,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "box-shadow 120ms",
        backgroundColor: checked ? ring : void 0,
        boxShadow: checked ? `inset 0 0 0 ${parseInt(outerSize, 10) / 2}px ${ring}` : void 0
      },
      children: checked && /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "span",
        {
          style: {
            width: dotSize,
            height: dotSize,
            borderRadius: "50%",
            backgroundColor: "#fff",
            filter: disabled ? "grayscale(1)" : "none"
          }
        }
      )
    }
  );
};
var Radio = (0, import_react14.forwardRef)(
  ({
    value,
    label,
    size: sizeProp,
    disabled = false,
    preset: p,
    children,
    style,
    className,
    ...inputRest
  }, ref) => {
    const { theme, mode } = useTheme();
    const { value: sel, setValue, name, size: groupSize } = useRadioGroup();
    const token = sizeProp ?? groupSize;
    const map = createSizeMap3(theme);
    let SZ;
    if (typeof token === "number") {
      const ind = `${token}px`;
      SZ = {
        indicator: ind,
        dot: `calc(${ind} * 0.6)`,
        gapInner: theme.spacing(0.75)
      };
    } else if (map[token]) {
      SZ = map[token];
    } else {
      const ind = token;
      SZ = {
        indicator: ind,
        dot: `calc(${ind} * 0.6)`,
        gapInner: theme.spacing(0.75)
      };
    }
    const checked = sel === value;
    const disabledColor = toHex(
      mix(
        toRgb(theme.colors.text),
        toRgb(mode === "dark" ? "#000" : "#fff"),
        0.4
      )
    );
    const onChange = () => !disabled && setValue(value);
    const presetCls = p ? preset(p) : "";
    const mergedCls = [presetCls, className].filter(Boolean).join(" ") || void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(
      OptionLabel,
      {
        className: mergedCls,
        style: { gap: SZ.gapInner, ...style },
        $disabled: disabled,
        $disabledColor: disabledColor,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
            HiddenInput2,
            {
              ...inputRest,
              ref,
              type: "radio",
              name,
              value,
              checked,
              disabled,
              onChange
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
            Indicator,
            {
              checked,
              outerSize: SZ.indicator,
              dotSize: SZ.dot,
              primary: theme.colors.primary,
              disabled,
              disabledColor
            }
          ),
          label ?? children
        ]
      }
    );
  }
);
Radio.displayName = "Radio";

// src/components/fields/Select.tsx
var import_react15 = __toESM(require("react"));
var import_jsx_runtime19 = require("react/jsx-runtime");
var geom3 = (t) => ({
  xs: { h: "1.5rem", pad: t.spacing(0.75), font: "0.625rem" },
  sm: { h: "1.875rem", pad: t.spacing(1), font: "0.75rem" },
  md: { h: "2.375rem", pad: t.spacing(1.25), font: "0.875rem" },
  lg: { h: "2.875rem", pad: t.spacing(1.5), font: "1rem" },
  xl: { h: "3.375rem", pad: t.spacing(1.75), font: "1.125rem" }
});
var Trigger = styled("button")`
    all: unset;
    box-sizing: border-box;
    width: 100%;
    height: ${({ $h }) => $h};
    padding: 0 ${({ $pad }) => $pad};
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 6px;
  
    border: 1px solid var(--valet-border,#ffffff22);
    border-radius: 6px;
    background: var(--valet-bg, ${({ $bg }) => $bg});
    color: var(--valet-text, ${({ $text }) => $text});
    cursor: pointer;
    transition: border-color .15s;
  
    &:hover:not([disabled]) { border-color: ${({ $primary }) => $primary}; }
    &:focus-visible         { outline:2px solid ${({ $primary }) => $primary};
                               outline-offset:2px; }
    &[disabled]             { opacity:.45; cursor:not-allowed; }
  `;
var Caret = styled("span")`
    border: solid currentColor;
    border-width: 0 1px 1px 0;
    padding: 3px;
    transform: rotate(45deg);
  `;
var PortalWrap = styled("div")`
    position: fixed;
    inset: 0;
    z-index: 9999;
  `;
var Menu = styled("ul")`
    position: absolute;
    min-width: ${({ $w }) => $w}px;
    width: max-content;
    max-width: min(100vw - 2rem, 360px);
    max-height: 260px;
    top: ${({ $top }) => $top}px;
    left: ${({ $left }) => $left}px;
    margin: 0;
    padding: 4px 0;
    list-style: none;
    border-radius: 6px;
    background: ${({ $bg }) => $bg};
    box-shadow: 0 8px 24px #00000040;
    overflow-y: auto;
    overflow-x: hidden;
  `;
var Item = styled("li")`
    padding: 6px ${({ $pad }) => $pad};
    cursor: ${({ $disabled }) => $disabled ? "not-allowed" : "pointer"};
    opacity:${({ $disabled }) => $disabled ? 0.45 : 1};
    background:${({ $active, $primary }) => $active ? $primary + "22" : "transparent"};
  
    &:hover:not([data-disabled='true']) {
      background: ${({ $primary }) => $primary + "33"};
    }
  `;
var eq = (a, b) => String(a) === String(b);
var array = (v) => Array.isArray(v) ? v : [v];
var Option = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(import_jsx_runtime19.Fragment, { children });
Option.displayName = "Select.Option";
var Inner = (props, ref) => {
  const {
    value: valueProp,
    initialValue,
    onChange,
    multiple = false,
    placeholder = "Select\u2026",
    size = "md",
    disabled = false,
    name,
    children,
    preset: presetKey,
    className,
    style,
    ...divRest
  } = props;
  const { theme } = useTheme();
  const map = geom3(theme);
  let g;
  if (typeof size === "number") {
    const h = `${size}px`;
    g = { h, pad: `${size * 0.26}px`, font: `calc(${h} * 0.35)` };
  } else if (map[size]) {
    g = map[size];
  } else {
    const h = size;
    g = { h, pad: `calc(${size} * 0.26)`, font: `calc(${size} * 0.35)` };
  }
  const textCol = theme.colors.text;
  const bg = theme.colors.surface;
  const bgElev = theme.colors.surfaceElevated ?? theme.colors.backgroundAlt ?? bg;
  const primary = theme.colors.primary;
  let form = null;
  try {
    form = useForm();
  } catch {
  }
  const formVal = form && name ? form.values[name] : void 0;
  const controlled = formVal !== void 0 || valueProp !== void 0;
  const [self, setSelf] = (0, import_react15.useState)(initialValue);
  const cur = controlled ? formVal !== void 0 ? formVal : valueProp : self;
  const commit = (0, import_react15.useCallback)(
    (next) => {
      if (!controlled) setSelf(next);
      if (form && name) form.setField(name, next);
      onChange?.(next);
    },
    [controlled, form, name, onChange]
  );
  const [open, setOpen] = (0, import_react15.useState)(false);
  const trigRef = (0, import_react15.useRef)(null);
  const menuRef = (0, import_react15.useRef)(null);
  const [pos, setPos] = (0, import_react15.useState)({ w: 0, top: 0, left: 0 });
  const calcPos = () => {
    if (!trigRef.current) return;
    const r = trigRef.current.getBoundingClientRect();
    setPos({ w: r.width, top: r.bottom + 4, left: r.left });
  };
  import_react15.default.useLayoutEffect(() => {
    if (!open) return;
    const onDoc = (e) => {
      if (menuRef.current && !menuRef.current.contains(e.target) && !trigRef.current?.contains(e.target)) setOpen(false);
    };
    const onEsc = (e) => e.key === "Escape" && setOpen(false);
    document.addEventListener("mousedown", onDoc);
    document.addEventListener("keydown", onEsc);
    return () => {
      document.removeEventListener("mousedown", onDoc);
      document.removeEventListener("keydown", onEsc);
    };
  }, [open]);
  const opts = (0, import_react15.useMemo)(
    () => import_react15.default.Children.toArray(children).filter(
      (n) => import_react15.default.isValidElement(n) && n.props.value !== void 0
    ),
    [children]
  );
  const [active, setActive] = (0, import_react15.useState)(0);
  const move = (dir) => {
    setActive((i) => {
      let n = i;
      do {
        n = (n + dir + opts.length) % opts.length;
      } while (opts[n].props.disabled);
      return n;
    });
  };
  const isSel = (v) => multiple ? array(cur ?? []).some((x) => eq(x, v)) : eq(cur, v);
  const toggle = (v) => {
    if (multiple) {
      const arr = array(cur ?? []);
      const exists = arr.some((x) => eq(x, v));
      commit(exists ? arr.filter((x) => !eq(x, v)) : [...arr, v]);
    } else {
      commit(v);
      setOpen(false);
    }
  };
  const label = (0, import_react15.useMemo)(() => {
    if (cur == null || Array.isArray(cur) && !cur.length) return placeholder;
    if (multiple) {
      return opts.filter((o) => array(cur).some((v) => eq(v, o.props.value))).map((o) => o.props.children).join(", ");
    }
    const found = opts.find((o) => eq(o.props.value, cur));
    return found ? found.props.children : placeholder;
  }, [cur, multiple, opts, placeholder]);
  const listId = (0, import_react15.useId)();
  const presetCls = presetKey ? preset(presetKey) : "";
  const mergedCls = [presetCls, className].filter(Boolean).join(" ") || void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(
    "div",
    {
      ...divRest,
      ref,
      className: mergedCls,
      style: { ...style, position: "relative", display: "inline-block" },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(
          Trigger,
          {
            ref: trigRef,
            $h: g.h,
            $pad: g.pad,
            $bg: bg,
            $text: textCol,
            $primary: primary,
            type: "button",
            role: "combobox",
            "aria-haspopup": "listbox",
            "aria-controls": listId,
            "aria-expanded": open,
            disabled,
            onClick: () => {
              if (disabled) return;
              setOpen((o) => !o);
              calcPos();
            },
            onKeyDown: (e) => {
              if (disabled) return;
              if (e.key === "ArrowDown") {
                e.preventDefault();
                setOpen(true);
                calcPos();
                move(1);
              }
              if (e.key === "ArrowUp") {
                e.preventDefault();
                setOpen(true);
                calcPos();
                move(-1);
              }
              if (e.key === " " || e.key === "Enter") {
                e.preventDefault();
                setOpen((o) => !o);
                calcPos();
              }
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("span", { style: { fontSize: g.font, flex: 1 }, children: label }),
              /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Caret, {})
            ]
          }
        ),
        open && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(PortalWrap, { children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
          Menu,
          {
            ref: menuRef,
            $w: pos.w,
            $top: pos.top,
            $left: pos.left,
            $bg: bgElev,
            role: "listbox",
            id: listId,
            children: opts.map((o, i) => {
              const sel = isSel(o.props.value);
              return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(
                Item,
                {
                  role: "option",
                  "aria-selected": sel,
                  "data-disabled": o.props.disabled,
                  $pad: g.pad,
                  $active: i === active,
                  $disabled: o.props.disabled,
                  $primary: primary,
                  onMouseEnter: () => setActive(i),
                  onClick: () => !o.props.disabled && toggle(o.props.value),
                  children: [
                    multiple && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
                      "input",
                      {
                        type: "checkbox",
                        readOnly: true,
                        checked: sel,
                        style: { marginRight: 6 }
                      }
                    ),
                    o.props.children
                  ]
                },
                o.props.value
              );
            })
          }
        ) })
      ]
    }
  );
};
var Forward = (0, import_react15.forwardRef)(Inner);
Forward.displayName = "Select";
Forward.Option = Option;
var Select = Forward;
var Select_default = Forward;

// src/components/fields/MetroSelect.tsx
var import_react16 = require("react");
var import_jsx_runtime20 = require("react/jsx-runtime");
var MetroCtx = (0, import_react16.createContext)(null);
var useMetro = () => {
  const ctx = (0, import_react16.useContext)(MetroCtx);
  if (!ctx) throw new Error("MetroSelect.Option must be inside MetroSelect");
  return ctx;
};
var Option2 = ({
  value,
  icon,
  label,
  disabled = false,
  preset: p,
  style,
  className,
  ...rest
}) => {
  const { theme } = useTheme();
  const { value: sel, setValue } = useMetro();
  const selected = sel !== null && String(sel) === String(value);
  const presetCls = p ? preset(p) : "";
  const innerStyle = {
    paddingTop: theme.spacing(3),
    paddingBottom: theme.spacing(3),
    paddingLeft: theme.spacing(1),
    paddingRight: theme.spacing(1),
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    gap: theme.spacing(1),
    height: "100%",
    width: "100%"
  };
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
    Panel_default,
    {
      ...rest,
      variant: "alt",
      compact: true,
      onClick: () => !disabled && setValue(value),
      style: {
        width: "6rem",
        height: "6rem",
        overflow: "hidden",
        cursor: disabled ? "not-allowed" : "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        borderColor: selected ? theme.colors.primary : void 0,
        background: selected ? theme.colors.primary : void 0,
        color: selected ? theme.colors.primaryText : void 0,
        ...style
      },
      className: [presetCls, className].filter(Boolean).join(" "),
      children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { style: innerStyle, children: [
        typeof icon === "string" ? /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Icon, { icon, size: "lg" }) : /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Icon, { size: "lg", children: icon }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(Typography, { variant: "h6", centered: true, noSelect: true, children: label })
      ] })
    }
  );
};
Option2.displayName = "MetroSelect.Option";
var MetroSelect = ({
  value: valueProp,
  defaultValue,
  gap = 0,
  onChange,
  preset: p,
  className,
  style,
  children,
  ...rest
}) => {
  const controlled = valueProp !== void 0;
  const [self, setSelf] = (0, import_react16.useState)(defaultValue ?? null);
  const val = controlled ? valueProp : self;
  const setValue = (0, import_react16.useCallback)(
    (v) => {
      if (!controlled) setSelf(v);
      onChange?.(v);
    },
    [controlled, onChange]
  );
  const presetCls = p ? preset(p) : "";
  const ctx = (0, import_react16.useMemo)(
    () => ({ value: val ?? null, setValue }),
    [val, setValue]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(MetroCtx.Provider, { value: ctx, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
    Stack_default,
    {
      direction: "row",
      wrap: true,
      spacing: 0.5 * Number(gap),
      compact: true,
      ...rest,
      style,
      className: [presetCls, className].filter(Boolean).join(" "),
      children
    }
  ) });
};
MetroSelect.displayName = "MetroSelect";
MetroSelect.Option = Option2;
var MetroSelect_default = MetroSelect;

// src/components/fields/Slider.tsx
var import_react17 = require("react");
var import_jsx_runtime21 = require("react/jsx-runtime");
var createSizeMap4 = (_) => ({
  xs: { trackH: "4px", thumb: "14px", tickH: "6px", font: "0.625rem" },
  sm: { trackH: "6px", thumb: "18px", tickH: "8px", font: "0.75rem" },
  md: { trackH: "8px", thumb: "22px", tickH: "10px", font: "0.875rem" },
  lg: { trackH: "10px", thumb: "26px", tickH: "12px", font: "1rem" },
  xl: { trackH: "14px", thumb: "34px", tickH: "16px", font: "1.125rem" }
});
var Wrapper3 = styled("div")`
    position: relative;
    width: 100%;
    touch-action: none;         /* prevent page pan while dragging */
    user-select: none;
  `;
var Track2 = styled("div")`
    position: relative;
    height: ${({ $h }) => $h};
    background: #0003;
    border-radius: 9999px;
    overflow: hidden;
  `;
var Fill = styled("div")`
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: ${({ $primary }) => $primary};
  `;
var Thumb = styled("button")`
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    width: ${({ $d }) => $d};
    height: ${({ $d }) => $d};
    border-radius: 50%;
    border: 2px solid #fff;
    background: ${({ $primary }) => $primary};
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: box-shadow 0.15s;
  
    &:focus-visible { box-shadow: 0 0 0 3px currentColor; }
    &:disabled      { opacity: 0.5; cursor: default; }
  `;
var ValueBubble = styled("span")`
    position: absolute;
    bottom: 100%;
    transform: translate(-50%, -0.5rem);
    padding: 0.125rem 0.25rem;
    border-radius: 0.25rem;
    background: var(--valet-bg, #fff);
    color: var(--valet-text-color, #000);
    font-size: ${({ $font }) => $font};
    white-space: nowrap;
    pointer-events: none;
  `;
var EndLabel = styled("span")`
    position: absolute;
    top: 100%;
    transform: translateY(0.5rem);
    font-size: ${({ $font }) => $font};
    color: var(--valet-text-color, #000);
    pointer-events: none;
    user-select: none;
  `;
var Tick = styled("span")`
    position: absolute;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 1px;
    height: ${({ $h }) => $h};
    background: currentColor;
    pointer-events: none;
  `;
var roundTo = (val, p) => parseFloat(val.toFixed(p));
var snapValue = (val, mode, step, presets) => {
  if (mode === "step") return Math.round(val / step) * step;
  if (mode === "presets") return presets.reduce((a, b) => Math.abs(b - val) < Math.abs(a - val) ? b : a, presets[0]);
  return val;
};
var Slider = (0, import_react17.forwardRef)(
  ({
    value: valueProp,
    defaultValue = 0,
    onChange,
    min = 0,
    max = 100,
    step = 1,
    presets = [],
    snap = "none",
    precision = 0,
    showValue = false,
    showMinMax = false,
    showTicks = false,
    ticks,
    name,
    size = "md",
    disabled = false,
    preset: p,
    className,
    style,
    ...rest
  }, forwardedRef) => {
    const { theme } = useTheme();
    const map = createSizeMap4(theme);
    let geom4;
    if (typeof size === "number") {
      const h = `${size}px`;
      geom4 = {
        trackH: h,
        thumb: `calc(${h} * 2 + 6px)`,
        tickH: `calc(${h} + 2px)`,
        font: `calc(${h} + 6px)`
      };
    } else if (map[size]) {
      geom4 = map[size];
    } else {
      const h = size;
      geom4 = {
        trackH: h,
        thumb: `calc(${h} * 2 + 6px)`,
        tickH: `calc(${h} + 2px)`,
        font: `calc(${h} + 6px)`
      };
    }
    let form = null;
    try {
      form = useForm();
    } catch {
    }
    const formVal = form && name ? form.values[name] : void 0;
    const controlled = formVal !== void 0 || valueProp !== void 0;
    const [self, setSelf] = (0, import_react17.useState)(defaultValue);
    const current = controlled ? formVal !== void 0 ? formVal : valueProp : self;
    const tickValues = (0, import_react17.useMemo)(() => {
      if (!showTicks) return [];
      if (ticks?.length) return ticks.filter((v) => v >= min && v <= max);
      if (snap === "step") {
        const out = [];
        for (let v = min; v <= max; v = roundTo(v + step, precision)) {
          out.push(v);
          if (v === max) break;
        }
        return out;
      }
      if (snap === "presets" && presets.length) return presets;
      const div = 10;
      return Array.from(
        { length: div + 1 },
        (_, i) => roundTo(min + i * (max - min) / div, precision)
      );
    }, [showTicks, ticks, snap, presets, min, max, step, precision]);
    const wrapRef = (0, import_react17.useRef)(null);
    const fillRef = (0, import_react17.useRef)(null);
    const thumbRef = (0, import_react17.useRef)(null);
    const pctFor = (val) => (val - min) / (max - min) * 100;
    const valFor = (pct) => min + (max - min) * pct / 100;
    const renderVisual = (val) => {
      const pct = pctFor(val);
      if (fillRef.current) fillRef.current.style.width = `${pct}%`;
      if (thumbRef.current) thumbRef.current.style.left = `${pct}%`;
    };
    (0, import_react17.useEffect)(() => {
      renderVisual(current);
    }, [current]);
    const commitValue = (0, import_react17.useCallback)((v) => {
      const snapped = snapValue(
        Math.min(Math.max(v, min), max),
        snap,
        step,
        presets
      );
      const rounded = roundTo(snapped, precision);
      if (!controlled) setSelf(rounded);
      form?.setField?.(name, rounded);
      onChange?.(rounded);
      renderVisual(rounded);
    }, [controlled, form, min, max, name, onChange, presets, snap, step, precision]);
    const pointerHandler = (0, import_react17.useCallback)((e) => {
      if (disabled) return;
      const rect = wrapRef.current.getBoundingClientRect();
      const pct = (e.clientX - rect.left) / rect.width * 100;
      commitValue(valFor(pct));
    }, [commitValue, disabled]);
    const onPointerDown = (e) => {
      e.preventDefault();
      pointerHandler(e);
      const move = (ev) => pointerHandler(ev);
      const up = () => {
        document.removeEventListener("pointermove", move);
        document.removeEventListener("pointerup", up);
      };
      document.addEventListener("pointermove", move);
      document.addEventListener("pointerup", up, { once: true });
    };
    const keyStep = snap === "step" ? step : (max - min) / 100;
    const onKeyDown = (e) => {
      if (disabled) return;
      let delta = 0;
      if (e.key === "ArrowRight" || e.key === "ArrowUp") delta = keyStep;
      if (e.key === "ArrowLeft" || e.key === "ArrowDown") delta = -keyStep;
      if (!delta) return;
      e.preventDefault();
      commitValue(current + delta);
    };
    const presetCls = p ? preset(p) : "";
    const mergedCls = [presetCls, className].filter(Boolean).join(" ") || void 0;
    const setWrapperRef = (0, import_react17.useCallback)((node) => {
      wrapRef.current = node;
      if (typeof forwardedRef === "function") {
        forwardedRef(node);
      } else if (forwardedRef && "current" in forwardedRef) {
        forwardedRef.current = node;
      }
    }, [forwardedRef]);
    const id = (0, import_react17.useId)();
    const format = (v) => precision ? v.toFixed(precision) : v;
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)(
      Wrapper3,
      {
        ...rest,
        ref: setWrapperRef,
        className: mergedCls,
        style,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
            Track2,
            {
              $h: geom4.trackH,
              onPointerDown,
              "aria-hidden": true,
              children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
                Fill,
                {
                  ref: fillRef,
                  $primary: theme.colors.primary
                }
              )
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
            Thumb,
            {
              ref: thumbRef,
              id,
              role: "slider",
              "aria-valuemin": min,
              "aria-valuemax": max,
              "aria-valuenow": current,
              "aria-disabled": disabled || void 0,
              tabIndex: disabled ? -1 : 0,
              disabled,
              $d: geom4.thumb,
              $primary: theme.colors.primary,
              onKeyDown,
              onPointerDown,
              style: { top: `calc(${geom4.trackH} / 2)` },
              children: showValue && /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(ValueBubble, { $font: geom4.font, children: format(current) })
            }
          ),
          showMinMax && /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)(import_jsx_runtime21.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(EndLabel, { $font: geom4.font, style: { left: 0 }, children: format(min) }),
            /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(EndLabel, { $font: geom4.font, style: { right: 0 }, children: format(max) })
          ] }),
          showTicks && tickValues.map((t) => /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
            Tick,
            {
              $h: geom4.tickH,
              style: { left: `${pctFor(t)}%` }
            },
            t
          ))
        ]
      }
    );
  }
);
Slider.displayName = "Slider";

// src/components/fields/Switch.tsx
var import_react18 = require("react");
var import_jsx_runtime22 = require("react/jsx-runtime");
var createSizeMap5 = (_) => ({
  sm: { trackW: 32, trackH: 18, thumb: 14, offset: 14 },
  // 32-18 = 14
  md: { trackW: 44, trackH: 24, thumb: 20, offset: 20 },
  // 44-24 = 20
  lg: { trackW: 56, trackH: 30, thumb: 26, offset: 26 }
  // 56-30 = 26
});
var Track3 = styled("button")`
    display        : inline-flex;
    align-items    : center;
    justify-content: flex-start;
    position       : relative;
    box-sizing     : border-box;
  
    width         : ${({ $w }) => $w}px;
    height        : ${({ $h }) => $h}px;
    min-width     : ${({ $w }) => $w}px;
    min-height    : ${({ $h }) => $h}px;
    padding       : 0;
    border        : none;
    border-radius : 9999px;
    background    : ${({ $checked, $primary }) => $checked ? $primary : "#0003"};
    cursor        : pointer;
    transition    : background 150ms ease;
  
    &:focus-visible {
      outline       : 2px solid ${({ $primary }) => $primary};
      outline-offset: 2px;
    }
    &:disabled {
      opacity: 0.5;
      cursor : default;
    }
  `;
var Thumb2 = styled("span")`
    position        : absolute;
    top             : 50%;
    left            : 2px;                /* 2-px gutter */
    transform       : translate(
      ${({ $checked, $offset }) => $checked ? `${$offset}px` : "0"},
      -50%
    );
    width           : ${({ $size }) => $size}px;
    height          : ${({ $size }) => $size}px;
    border-radius   : 50%;
    background      : #fff;
    box-shadow      : 0 1px 3px rgba(0,0,0,0.45);
    transition      : transform 150ms ease;
    pointer-events  : none;               /* retain click on Track */
  `;
var Switch = (0, import_react18.forwardRef)(
  ({
    checked: checkedProp,
    defaultChecked = false,
    onChange,
    name,
    size = "md",
    disabled = false,
    preset: p,
    className,
    style,
    ...btnProps
  }, ref) => {
    const { theme } = useTheme();
    const geom4 = createSizeMap5(theme)[size];
    let form = null;
    try {
      form = useForm();
    } catch {
    }
    const formChecked = form && name ? Boolean(form.values[name]) : void 0;
    const controlled = checkedProp !== void 0 || formChecked !== void 0;
    const [self, setSelf] = (0, import_react18.useState)(defaultChecked);
    const checked = controlled ? formChecked !== void 0 ? formChecked : !!checkedProp : self;
    const handleToggle = (0, import_react18.useCallback)((e) => {
      if (disabled) return;
      const next = !checked;
      if (!controlled) setSelf(next);
      form?.setField?.(name, next);
      onChange?.(next);
      btnProps.onClick?.(e);
    }, [checked, controlled, disabled, form, name, onChange, btnProps]);
    const presetClasses = p ? preset(p) : "";
    const switchId = (0, import_react18.useId)();
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      Track3,
      {
        ...btnProps,
        ref,
        role: "switch",
        id: switchId,
        "aria-checked": checked,
        "aria-disabled": disabled || void 0,
        disabled,
        onClick: handleToggle,
        $checked: checked,
        $w: geom4.trackW,
        $h: geom4.trackH,
        $primary: theme.colors.primary,
        className: [presetClasses, className].filter(Boolean).join(" "),
        style,
        children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
          Thumb2,
          {
            $checked: checked,
            $size: geom4.thumb,
            $offset: geom4.offset
          }
        )
      }
    );
  }
);
Switch.displayName = "Switch";

// src/components/fields/TextField.tsx
var import_react19 = require("react");
var import_jsx_runtime23 = require("react/jsx-runtime");
var sharedFieldCSS = ({ theme, $error }) => `
  padding: ${theme.spacing(1)} ${theme.spacing(1)};
  border: 1px solid ${($error ? theme.colors.secondary : theme.colors.text) + "44"};
  border-radius: 4px;
  background: ${theme.colors.background};
  color: ${theme.colors.text};
  font-size: 0.875rem;
  width: 100%;
  &:focus {
    outline: 2px solid ${theme.colors.primary};
    outline-offset: 1px;
  }
`;
var FieldInput = styled("input")`
  ${sharedFieldCSS}
`;
var FieldTextarea = styled("textarea")`
  ${sharedFieldCSS}
  resize: vertical;
`;
var Wrapper4 = styled("div")`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing(1)};
`;
var Label = styled("label")`
  font-size: 0.75rem;
  color: ${({ theme }) => theme.colors.text};
`;
var Helper = styled("span")`
  font-size: 0.75rem;
  color: ${({ theme, $error }) => ($error ? theme.colors.secondary : theme.colors.text) + "AA"};
`;
var TextField = (0, import_react19.forwardRef)((props, ref) => {
  const {
    as = "input",
    name,
    label,
    helperText,
    error = false,
    fullWidth = false,
    preset: presetName,
    className,
    rows,
    style: styleProp,
    ...rawRest
  } = props;
  const {
    onChange: externalOnChange,
    value: externalValue,
    defaultValue,
    ...rest
  } = rawRest;
  const id = (0, import_react19.useId)();
  const { theme } = useTheme();
  let form = null;
  try {
    form = useForm();
  } catch {
  }
  const controlledValue = form ? form.values[name] ?? "" : externalValue;
  const setField = form ? form.setField : void 0;
  const handleChange = (e) => {
    setField?.(name, e.target.value);
    externalOnChange?.(e);
  };
  const presetClasses = presetName ? preset(presetName) : "";
  const Element = as === "textarea" ? FieldTextarea : FieldInput;
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(
    Wrapper4,
    {
      theme,
      className: [presetClasses, className].filter(Boolean).join(" "),
      style: fullWidth ? { flex: 1, width: "100%", ...styleProp } : styleProp,
      children: [
        label && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Label, { theme, htmlFor: id, children: label }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
          Element,
          {
            id,
            name,
            ref,
            theme,
            $error: error,
            rows: as === "textarea" ? rows : void 0,
            ...rest,
            value: controlledValue,
            defaultValue,
            onChange: handleChange
          }
        ),
        helperText && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Helper, { theme, $error: error, children: helperText })
      ]
    }
  );
});
TextField.displayName = "TextField";
var TextField_default = TextField;

// src/components/fields/Iterator.tsx
var import_react20 = require("react");
var import_jsx_runtime24 = require("react/jsx-runtime");
var Wrapper5 = styled("div")`
  display: inline-flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing(0.75)};
`;
var Field = styled("input")`
  padding: ${({ theme }) => theme.spacing(0.5)};
  border: 1px solid ${({ theme }) => theme.colors.text + "44"};
  border-radius: 4px;
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.875rem;
  text-align: center;
  width: ${({ $w }) => $w};
  overscroll-behavior: contain;
  -moz-appearance: textfield;
  &::-webkit-inner-spin-button,
  &::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  &:focus {
    outline: 2px solid ${({ theme }) => theme.colors.primary};
    outline-offset: 1px;
  }
`;
var Iterator = (0, import_react20.forwardRef)(
  ({
    value: valueProp,
    defaultValue,
    onChange,
    name,
    min,
    max,
    step = 1,
    width = "3.5rem",
    disabled = false,
    preset: p,
    className,
    style,
    ...rest
  }, ref) => {
    const { theme } = useTheme();
    const localRef = (0, import_react20.useRef)(null);
    const setRef = (0, import_react20.useCallback)(
      (node) => {
        localRef.current = node;
        if (typeof ref === "function") ref(node);
        else if (ref) ref.current = node;
      },
      [ref]
    );
    let form = null;
    try {
      form = useForm();
    } catch {
    }
    const formVal = form && name ? form.values[name] : void 0;
    const controlled = valueProp !== void 0 || formVal !== void 0;
    const [internal, setInternal] = (0, import_react20.useState)(defaultValue ?? 0);
    const current = controlled ? formVal ?? valueProp : internal;
    const [text, setText] = (0, import_react20.useState)(String(current));
    (0, import_react20.useEffect)(() => {
      setText(String(current));
    }, [current]);
    const commit = (next) => {
      if (min !== void 0 && next < min) next = min;
      if (max !== void 0 && next > max) next = max;
      if (!controlled) setInternal(next);
      form?.setField(name, next);
      onChange?.(next);
      setText(String(next));
    };
    const handleInput = (e) => {
      const val = e.target.value;
      setText(val);
      const num = parseFloat(val);
      if (!Number.isNaN(num)) commit(num);
    };
    const handleBlur = () => {
      const num = parseFloat(text);
      if (Number.isNaN(num)) setText(String(current));
      else commit(num);
    };
    const stepBy = (0, import_react20.useCallback)((dir) => {
      commit(current + dir * step);
    }, [current, step]);
    const handleWheel = (0, import_react20.useCallback)((e) => {
      if (disabled) return;
      e.preventDefault();
      e.stopPropagation();
      stepBy(e.deltaY < 0 ? 1 : -1);
    }, [disabled, stepBy]);
    (0, import_react20.useEffect)(() => {
      const node = localRef.current;
      if (!node) return;
      node.addEventListener("wheel", handleWheel, { passive: false });
      return () => node.removeEventListener("wheel", handleWheel);
    }, [handleWheel]);
    const cls = [p ? preset(p) : "", className].filter(Boolean).join(" ") || void 0;
    const w = typeof width === "number" ? `${width}px` : width;
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(Wrapper5, { theme, className: cls, style, children: [
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        IconButton,
        {
          size: "xs",
          variant: "outlined",
          icon: "mdi:minus",
          onClick: () => stepBy(-1),
          disabled,
          "aria-label": "decrement"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        Field,
        {
          ...rest,
          ref: setRef,
          type: "number",
          inputMode: "numeric",
          theme,
          $w: w,
          value: text,
          onChange: handleInput,
          onBlur: handleBlur,
          disabled
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        IconButton,
        {
          size: "xs",
          variant: "outlined",
          icon: "mdi:plus",
          onClick: () => stepBy(1),
          disabled,
          "aria-label": "increment"
        }
      )
    ] });
  }
);
Iterator.displayName = "Iterator";

// src/components/layout/Accordion.tsx
var import_react21 = __toESM(require("react"));
var import_shallow3 = require("zustand/shallow");
var import_jsx_runtime25 = require("react/jsx-runtime");
var AccordionCtx = (0, import_react21.createContext)(null);
var useAccordion = () => {
  const ctx = (0, import_react21.useContext)(AccordionCtx);
  if (!ctx) throw new Error("<Accordion.Item> must be inside <Accordion>");
  return ctx;
};
var Root4 = styled("div")`
  width      : 100%;
  box-sizing : border-box;
  margin     : ${({ $gap }) => $gap};
  & > * {
    padding: ${({ $gap }) => $gap};
  }
`;
var Wrapper6 = styled("div")`
  width:100%;
  display:block;
  box-sizing:border-box;
  min-height:0;
`;
var ItemWrapper = styled("div")`
  border-bottom: 1px solid currentColor;
`;
var HeaderBtn = styled("button")`
  width           : 100%;
  display         : flex;
  justify-content : space-between;
  align-items     : center;
  gap             : 1rem;
  padding         : 1rem ${({ $shift }) => $shift};
  background      : transparent;
  border          : none;
  color           : inherit;
  font            : inherit;
  cursor          : pointer;
  text-align      : left;
  appearance      : none;
  box-sizing      : border-box;
  margin-inline-start: -${({ $shift }) => $shift};
  margin-inline-end  : -${({ $shift }) => $shift};

  /* Disable blue tap-highlight on mobile */
  -webkit-tap-highlight-color: transparent;

  transition: background 200ms ease;

  /* Hover tint – only on devices that actually support hover */
  @media (hover: hover) {
    &:hover:not(:disabled) {
      ${({ $skipHover, $hoverBg }) => $skipHover ? "" : `background:${$hoverBg};`}
    }
  }

  ${({ $open, $highlight }) => $open && `background:${$highlight};`}

  &:focus-visible {
    outline       : 2px solid ${({ $primary }) => $primary};
    outline-offset: 2px;
  }

  &:disabled {
    color : ${({ $disabledColor }) => $disabledColor};
    cursor: not-allowed;
  }
`;
var Chevron = styled("svg")`
  width      : 1em;
  height     : 1em;
  flex-shrink: 0;
  transition : transform 200ms cubic-bezier(0.4, 0, 0.2, 1);
  transform  : rotate(${({ $open }) => $open ? 0 : 180}deg);
`;
var Content2 = styled("div")`
  overflow : hidden;
  height   : ${({ $open, $height }) => $open ? `${$height}px` : "0"};
  transition: height 300ms cubic-bezier(0.4, 0, 0.2, 1);
  will-change: height;
`;
var Accordion = ({
  defaultOpen,
  open: openProp,
  multiple = false,
  onOpenChange,
  headingLevel = 3,
  constrainHeight = true,
  preset: p,
  className,
  children,
  ...divProps
}) => {
  const { theme } = useTheme();
  const surface = useSurface(
    (s) => ({
      element: s.element,
      height: s.height,
      registerChild: s.registerChild,
      unregisterChild: s.unregisterChild
    }),
    import_shallow3.shallow
  );
  const wrapRef = (0, import_react21.useRef)(null);
  const uniqueId = (0, import_react21.useId)();
  const [maxHeight, setMaxHeight] = (0, import_react21.useState)();
  const [shouldConstrain, setShouldConstrain] = (0, import_react21.useState)(false);
  const constraintRef = (0, import_react21.useRef)(false);
  const controlled = openProp !== void 0;
  const toArray = (v) => v === void 0 ? [] : Array.isArray(v) ? v : [v];
  const [selfOpen, setSelfOpen] = (0, import_react21.useState)(() => toArray(defaultOpen));
  const open = controlled ? toArray(openProp) : selfOpen;
  const toggle = (0, import_react21.useCallback)(
    (idx) => {
      let next;
      const isOpen = open.includes(idx);
      if (isOpen) next = open.filter((i) => i !== idx);
      else if (multiple) next = [...open, idx];
      else next = [idx];
      if (!controlled) setSelfOpen(next);
      onOpenChange?.(next);
    },
    [controlled, multiple, onOpenChange, open]
  );
  const ctx = (0, import_react21.useMemo)(
    () => ({
      open,
      toggle,
      multiple,
      headerTag: `h${headingLevel}`
    }),
    [open, toggle, multiple, headingLevel]
  );
  const presetClasses = p ? preset(p) : "";
  const calcCutoff = () => {
    if (typeof document === "undefined") return 32;
    const fs = parseFloat(
      getComputedStyle(document.documentElement).fontSize
    );
    return (isNaN(fs) ? 16 : fs) * 2;
  };
  const bottomRef = (0, import_react21.useRef)(0);
  const rafRef = (0, import_react21.useRef)(0);
  const prevHeightRef = (0, import_react21.useRef)(void 0);
  const prevConstrainedRef = (0, import_react21.useRef)(false);
  const runUpdate = () => {
    const node = wrapRef.current;
    const surfEl = surface.element;
    if (!node || !surfEl) return;
    const sRect = surfEl.getBoundingClientRect();
    const nRect = node.getBoundingClientRect();
    const top = Math.round(nRect.top - sRect.top + surfEl.scrollTop);
    const dynBottom = Math.round(
      surfEl.scrollHeight - (nRect.bottom - sRect.top + surfEl.scrollTop)
    );
    if (!constraintRef.current) bottomRef.current = dynBottom;
    const available = Math.round(surface.height - top - bottomRef.current);
    const cutoff = calcCutoff();
    const shouldClamp = node.scrollHeight - available > 1 && available >= cutoff;
    if (shouldClamp) {
      if (!constraintRef.current) {
        surfEl.scrollTop = 0;
        surfEl.scrollLeft = 0;
      }
      constraintRef.current = true;
      if (!prevConstrainedRef.current) {
        prevConstrainedRef.current = true;
        setShouldConstrain(true);
      }
      const newHeight = Math.max(0, available);
      if (prevHeightRef.current !== newHeight) {
        prevHeightRef.current = newHeight;
        setMaxHeight(newHeight);
      }
    } else {
      constraintRef.current = false;
      bottomRef.current = dynBottom;
      if (prevConstrainedRef.current) {
        prevConstrainedRef.current = false;
        setShouldConstrain(false);
      }
      if (prevHeightRef.current !== void 0) {
        prevHeightRef.current = void 0;
        setMaxHeight(void 0);
      }
    }
  };
  const update = () => {
    if (rafRef.current) cancelAnimationFrame(rafRef.current);
    rafRef.current = requestAnimationFrame(runUpdate);
  };
  (0, import_react21.useEffect)(() => {
    if (!constrainHeight) {
      constraintRef.current = false;
      setShouldConstrain(false);
      setMaxHeight(void 0);
    } else {
      constraintRef.current = false;
    }
  }, [constrainHeight]);
  (0, import_react21.useLayoutEffect)(() => {
    if (!constrainHeight || !wrapRef.current || !surface.element) return;
    const node = wrapRef.current;
    surface.registerChild(uniqueId, node, update);
    const ro = new ResizeObserver(update);
    ro.observe(node);
    update();
    return () => {
      surface.unregisterChild(uniqueId);
      ro.disconnect();
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [constrainHeight, surface.element]);
  (0, import_react21.useLayoutEffect)(() => {
    if (!constrainHeight || !wrapRef.current || !surface.element) return;
    update();
  }, [constrainHeight, surface.height, surface.element]);
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(AccordionCtx.Provider, { value: ctx, children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    Wrapper6,
    {
      ref: wrapRef,
      style: shouldConstrain ? { overflow: "auto", maxHeight } : void 0,
      children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
        Root4,
        {
          ...divProps,
          $gap: theme.spacing(1),
          className: [presetClasses, className].filter(Boolean).join(" "),
          children: import_react21.default.Children.map(
            children,
            (child, idx) => import_react21.default.isValidElement(child) ? import_react21.default.cloneElement(child, { index: idx }) : child
          )
        }
      )
    }
  ) });
};
var AccordionItem = ({
  header,
  children,
  disabled = false,
  preset: p,
  className,
  index = 0,
  ...divProps
}) => {
  const { theme, mode } = useTheme();
  const { open, toggle, headerTag } = useAccordion();
  const longPressTimer = (0, import_react21.useRef)(null);
  const wasLongPress = (0, import_react21.useRef)(false);
  const contentRef = (0, import_react21.useRef)(null);
  const [height, setHeight] = (0, import_react21.useState)(0);
  const [skipHover, setSkipHover] = (0, import_react21.useState)(false);
  const hoverTimer = (0, import_react21.useRef)(null);
  const moveHandler = (0, import_react21.useRef)(null);
  const disableHoverUntilMove = () => {
    if (hoverTimer.current) clearTimeout(hoverTimer.current);
    setSkipHover(true);
    const remove = () => {
      if (moveHandler.current) {
        window.removeEventListener("pointermove", moveHandler.current);
        moveHandler.current = null;
      }
      if (hoverTimer.current) {
        clearTimeout(hoverTimer.current);
        hoverTimer.current = null;
      }
      setSkipHover(false);
    };
    moveHandler.current = () => remove();
    window.addEventListener("pointermove", moveHandler.current, { once: true });
    hoverTimer.current = setTimeout(remove, 1e3);
  };
  const isOpen = open.includes(index);
  (0, import_react21.useLayoutEffect)(() => {
    if (contentRef.current) {
      setHeight(contentRef.current.scrollHeight);
    }
  }, [children, isOpen]);
  const headerId = `acc-btn-${index}`;
  const panelId = `acc-panel-${index}`;
  const disabledColor = toHex(
    mix(
      toRgb(theme.colors.text),
      toRgb(mode === "dark" ? "#000" : "#fff"),
      0.4
    )
  );
  const presetClasses = p ? preset(p) : "";
  const HeaderTag = headerTag;
  const highlight = toHex(
    mix(toRgb(theme.colors.primary), toRgb(theme.colors.background), 0.15)
  );
  const hoverBg = toHex(
    mix(toRgb(theme.colors.primary), toRgb(theme.colors.background), 0.6)
  );
  const shift = theme.spacing(1);
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(ItemWrapper, { ...divProps, className: [presetClasses, className].filter(Boolean).join(" "), children: [
    /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(HeaderTag, { style: { margin: 0 }, children: /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(
      HeaderBtn,
      {
        id: headerId,
        type: "button",
        "aria-expanded": isOpen,
        "aria-controls": panelId,
        disabled,
        onClick: () => toggle(index),
        onContextMenu: (e) => {
          e.preventDefault();
          if (!disabled && !wasLongPress.current) toggle(index);
          wasLongPress.current = false;
        },
        onPointerDown: (e) => {
          if (hoverTimer.current) {
            clearTimeout(hoverTimer.current);
            hoverTimer.current = null;
          }
          if (moveHandler.current) {
            window.removeEventListener("pointermove", moveHandler.current);
            moveHandler.current = null;
          }
          setSkipHover(true);
          if (e.pointerType === "touch") {
            longPressTimer.current = setTimeout(() => {
              wasLongPress.current = true;
              if (!disabled) toggle(index);
            }, 500);
          }
        },
        onPointerUp: () => {
          if (longPressTimer.current) {
            clearTimeout(longPressTimer.current);
            longPressTimer.current = null;
          }
          wasLongPress.current = false;
          disableHoverUntilMove();
        },
        onPointerLeave: () => {
          if (hoverTimer.current) {
            clearTimeout(hoverTimer.current);
            hoverTimer.current = null;
          }
          if (moveHandler.current) {
            window.removeEventListener("pointermove", moveHandler.current);
            moveHandler.current = null;
          }
          setSkipHover(false);
          if (longPressTimer.current) {
            clearTimeout(longPressTimer.current);
            longPressTimer.current = null;
          }
          wasLongPress.current = false;
        },
        onPointerCancel: () => {
          if (hoverTimer.current) {
            clearTimeout(hoverTimer.current);
            hoverTimer.current = null;
          }
          if (moveHandler.current) {
            window.removeEventListener("pointermove", moveHandler.current);
            moveHandler.current = null;
          }
          setSkipHover(false);
          if (longPressTimer.current) {
            clearTimeout(longPressTimer.current);
            longPressTimer.current = null;
          }
          wasLongPress.current = false;
        },
        $open: isOpen,
        $primary: theme.colors.primary,
        $disabledColor: disabledColor,
        $highlight: highlight,
        $hoverBg: hoverBg,
        $shift: shift,
        $skipHover: skipHover,
        children: [
          typeof header === "string" || typeof header === "number" ? /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(Typography, { variant: "subtitle", noSelect: true, style: { font: "inherit" }, children: header }) : header,
          /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(Chevron, { "aria-hidden": true, $open: isOpen, viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
            "path",
            {
              d: "M6 9l6 6 6-6",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ) })
        ]
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
      Content2,
      {
        role: "region",
        id: panelId,
        "aria-labelledby": headerId,
        $open: isOpen,
        $height: height,
        children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { ref: contentRef, style: { padding: "0.75rem 0" }, children })
      }
    )
  ] });
};
AccordionItem.displayName = "Accordion.Item";
Accordion.Item = AccordionItem;

// src/components/layout/AppBar.tsx
var import_react22 = require("react");
var import_react_dom2 = require("react-dom");
var import_shallow4 = require("zustand/shallow");
var import_jsx_runtime26 = require("react/jsx-runtime");
var Bar2 = styled("header")`
  box-sizing: border-box;
  display: flex;
  align-items: center;
  padding: 0.5rem 1rem;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 10000;
  color: ${({ $text }) => $text};
  & > * {
    padding: ${({ $pad }) => $pad};
  }
`;
var BarBg = styled("div")`
  position: absolute;
  inset: 0;
  background: ${({ $bg }) => $bg};
  pointer-events: none;
  z-index: -1;
`;
var LeftWrap = styled("div")`
  display: flex;
  align-items: center;
  gap: ${({ $gap }) => $gap};
`;
var RightWrap = styled("div")`
  margin-left: auto;
  display: flex;
  align-items: center;
`;
var AppBar = ({
  color,
  textColor,
  left,
  right,
  preset: p,
  className,
  style,
  children,
  ...rest
}) => {
  const { theme } = useTheme();
  const { element, registerChild, unregisterChild } = useSurface(
    (s) => ({
      element: s.element,
      registerChild: s.registerChild,
      unregisterChild: s.unregisterChild
    }),
    import_shallow4.shallow
  );
  const ref = (0, import_react22.useRef)(null);
  const id = (0, import_react22.useId)();
  const isToken = (v) => v === "primary" || v === "secondary" || v === "tertiary";
  const bg = color === void 0 ? theme.colors.primary : isToken(color) ? theme.colors[color] : color;
  const text = textColor === void 0 ? isToken(color) ? theme.colors[`${color}Text`] : theme.colors.text : isToken(textColor) ? theme.colors[`${textColor}Text`] : textColor;
  const presetClass = p ? preset(p) : "";
  const pad = theme.spacing(1);
  const gap = theme.spacing(2);
  (0, import_react22.useLayoutEffect)(() => {
    const node = ref.current;
    const surfEl = element;
    if (!node || !surfEl) return;
    const prev = surfEl.style.marginTop;
    const update = (m) => {
      surfEl.style.marginTop = `${m.height}px`;
    };
    registerChild(id, node, update);
    return () => {
      unregisterChild(id);
      surfEl.style.marginTop = prev;
    };
  }, [element]);
  const bar = /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)(
    Bar2,
    {
      ref,
      ...rest,
      $text: text,
      $pad: pad,
      className: [presetClass, className].filter(Boolean).join(" "),
      style: {
        "--valet-bg": bg,
        "--valet-text-color": text,
        background: bg,
        color: text,
        ...style
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(BarBg, { $bg: bg }),
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(LeftWrap, { $gap: gap, children: left ?? children }),
        right && /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(RightWrap, { children: right })
      ]
    }
  );
  return (0, import_react_dom2.createPortal)(bar, document.body);
};

// src/components/widgets/LLMChat.tsx
var import_react26 = require("react");
var import_shallow6 = require("zustand/shallow");

// src/components/widgets/Markdown.tsx
var import_react24 = __toESM(require("react"));
var import_marked = require("marked");

// src/components/widgets/Table.tsx
var import_react23 = require("react");
var import_shallow5 = require("zustand/shallow");
var import_jsx_runtime27 = require("react/jsx-runtime");
var Wrapper7 = styled("div")`
  width: 100%;
  display: block;
  box-sizing: border-box;
  overflow-x: hidden;       /* never allow horizontal scroll */
  padding-inline: ${({ $pad }) => $pad};
`;
var Root5 = styled("table")`
  /* leave a subtle gutter so right border never clips */
  width: calc(100% - ${({ $gutter }) => $gutter} * 2);
  max-width: 100%;
  margin-inline: auto;

  border-collapse: collapse;
  box-sizing: border-box;
  border: 1px solid ${({ $border }) => $border};
  table-layout: fixed; /* prevents cells pushing past width */

  th, td {
    padding: 0.5rem 0.75rem;
    text-align: left;
    border-bottom: 1px solid ${({ $border }) => $border};
    transition: background 120ms ease;
    word-break: break-word;
    overflow-wrap: anywhere;
  }
  th code, td code { word-break: break-word; overflow-wrap: anywhere; }

  /* Zebra stripes */
  ${({ $striped, $stripe }) => $striped && `
    tbody tr:nth-of-type(odd) td { background: ${$stripe}; }
  `}

  /* Row hover */
  ${({ $hover, $hoverBg }) => $hover && `
    tbody tr:hover,
    tbody tr:hover > td { background: ${$hoverBg}; }
  `}

  /* Column dividers */
  ${({ $lines, $border }) => $lines && `
    th:not(:last-child), td:not(:last-child) { border-right: 1px solid ${$border}; }
  `}
`;
var Th = styled("th")`
  text-align: ${({ $align }) => $align};
  ${({ $sortable }) => $sortable && "cursor: pointer; user-select: none;"}
  position: relative;
  &:hover { ${({ $sortable }) => $sortable && "filter: brightness(0.9);"} }
  &::after {
    content: '';
    position: absolute;
    left: 0; right: 0; bottom: -1px;
    height: 4px;
    background: ${({ $primary, $active }) => $active ? $primary : "transparent"};
    transition: background 150ms ease;
  }
`;
var Td = styled("td")`
  text-align: ${({ $align }) => $align};
`;
function Table({
  data,
  columns,
  striped = true,
  hoverable = false,
  dividers = true,
  selectable,
  initialSort,
  onSortChange,
  onSelectionChange,
  constrainHeight = true,
  preset: p,
  className,
  style,
  ...rest
}) {
  const { theme } = useTheme();
  const surface = useSurface(
    (s) => ({ element: s.element, height: s.height, registerChild: s.registerChild, unregisterChild: s.unregisterChild }),
    import_shallow5.shallow
  );
  const wrapRef = (0, import_react23.useRef)(null);
  const uniqueId = (0, import_react23.useId)();
  const pad = theme.spacing(1);
  const [maxHeight, setMaxHeight] = (0, import_react23.useState)();
  const [shouldConstrain, setShouldConstrain] = (0, import_react23.useState)(false);
  const constraintRef = (0, import_react23.useRef)(false);
  const bottomRef = (0, import_react23.useRef)(0);
  const rafRef = (0, import_react23.useRef)(0);
  const prevHeightRef = (0, import_react23.useRef)(void 0);
  const prevConstrainedRef = (0, import_react23.useRef)(false);
  const calcCutoff = () => {
    if (typeof document === "undefined") return 32;
    const fs = parseFloat(getComputedStyle(document.documentElement).fontSize);
    return (isNaN(fs) ? 16 : fs) * 2;
  };
  const runUpdate = () => {
    const node = wrapRef.current;
    const surfEl = surface.element;
    if (!node || !surfEl) return;
    const sRect = surfEl.getBoundingClientRect();
    const nRect = node.getBoundingClientRect();
    const top = Math.round(nRect.top - sRect.top + surfEl.scrollTop);
    const dynBottom = Math.round(
      surfEl.scrollHeight - (nRect.bottom - sRect.top + surfEl.scrollTop)
    );
    if (!constraintRef.current) bottomRef.current = dynBottom;
    const available = Math.round(surface.height - top - bottomRef.current);
    const cutoff = calcCutoff();
    const shouldClamp = node.scrollHeight - available > 1 && available >= cutoff;
    if (shouldClamp) {
      if (!constraintRef.current) {
        surfEl.scrollTop = 0;
        surfEl.scrollLeft = 0;
      }
      constraintRef.current = true;
      if (!prevConstrainedRef.current) {
        prevConstrainedRef.current = true;
        setShouldConstrain(true);
      }
      const newHeight = Math.max(0, available);
      if (prevHeightRef.current !== newHeight) {
        prevHeightRef.current = newHeight;
        setMaxHeight(newHeight);
      }
    } else {
      constraintRef.current = false;
      bottomRef.current = dynBottom;
      if (prevConstrainedRef.current) {
        prevConstrainedRef.current = false;
        setShouldConstrain(false);
      }
      if (prevHeightRef.current !== void 0) {
        prevHeightRef.current = void 0;
        setMaxHeight(void 0);
      }
    }
  };
  const update = () => {
    if (rafRef.current) cancelAnimationFrame(rafRef.current);
    rafRef.current = requestAnimationFrame(runUpdate);
  };
  (0, import_react23.useEffect)(() => {
    if (!constrainHeight) {
      constraintRef.current = false;
      setShouldConstrain(false);
      setMaxHeight(void 0);
    } else {
      constraintRef.current = false;
    }
  }, [constrainHeight]);
  (0, import_react23.useLayoutEffect)(() => {
    if (!constrainHeight || !wrapRef.current || !surface.element) return;
    const node = wrapRef.current;
    surface.registerChild(uniqueId, node, update);
    const ro = new ResizeObserver(update);
    ro.observe(node);
    update();
    return () => {
      surface.unregisterChild(uniqueId);
      ro.disconnect();
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
    };
  }, [constrainHeight, surface.element]);
  (0, import_react23.useLayoutEffect)(() => {
    if (!constrainHeight || !wrapRef.current || !surface.element) return;
    update();
  }, [constrainHeight, surface.height, surface.element]);
  const [sort, setSort] = (0, import_react23.useState)(initialSort ? { index: initialSort.index, desc: !!initialSort.desc } : null);
  const [selected, setSelected] = (0, import_react23.useState)(/* @__PURE__ */ new Set());
  (0, import_react23.useEffect)(() => {
    setSelected((prev) => {
      const next = new Set(Array.from(prev).filter((r) => data.includes(r)));
      onSelectionChange?.(Array.from(next));
      return next;
    });
  }, [data]);
  const stripeColor = stripe(theme.colors.background, theme.colors.text);
  const hoverBg = toHex(mix(toRgb(theme.colors.primary), toRgb(theme.colors.background), 0.25));
  const toggleSort = (idx) => {
    setSort((prev) => {
      const next = !prev || prev.index !== idx ? { index: idx, desc: false } : { index: idx, desc: !prev.desc };
      onSortChange?.(next.index, next.desc);
      return next;
    });
  };
  const toggleSelect = (row, checked) => {
    setSelected((prev) => {
      const next = new Set(prev);
      if (selectable === "single") next.clear();
      checked ? next.add(row) : next.delete(row);
      onSelectionChange?.(Array.from(next));
      return next;
    });
  };
  const sorted = (0, import_react23.useMemo)(() => {
    if (!sort) return data;
    const col = columns[sort.index];
    if (!col || !col.sortable) return data;
    const cmp = typeof col.sortable === "function" ? col.sortable : (a, b) => {
      const getter = typeof col.accessor === "function" ? col.accessor : (row) => row[col.accessor];
      const va = getter(a);
      const vb = getter(b);
      return va > vb ? 1 : va < vb ? -1 : 0;
    };
    const arr = [...data].sort(cmp);
    return sort.desc ? arr.reverse() : arr;
  }, [data, columns, sort]);
  const cls = [p ? preset(p) : "", className].filter(Boolean).join(" ") || void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
    Wrapper7,
    {
      ref: wrapRef,
      $pad: pad,
      style: shouldConstrain ? { overflow: "auto", maxHeight } : void 0,
      children: /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(
        Root5,
        {
          ...rest,
          $striped: striped,
          $hover: hoverable,
          $lines: dividers,
          $border: theme.colors.backgroundAlt,
          $stripe: stripeColor,
          $hoverBg: hoverBg,
          $gutter: pad,
          className: cls,
          style,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("tr", { children: [
              selectable && /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Th, { $align: "center", $sortable: false, $active: false, $primary: theme.colors.primary, style: { width: 48 } }),
              columns.map((c, i) => /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(
                Th,
                {
                  $align: c.align ?? "left",
                  $sortable: !!c.sortable,
                  $active: sort?.index === i,
                  $primary: theme.colors.primary,
                  onClick: c.sortable ? () => toggleSort(i) : void 0,
                  children: [
                    c.header,
                    sort?.index === i && (sort.desc ? " \u25BC" : " \u25B2")
                  ]
                },
                i
              ))
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("tbody", { children: sorted.map((row, rIdx) => /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("tr", { children: [
              selectable && /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Td, { $align: "center", children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
                Checkbox,
                {
                  name: `sel-${rIdx}`,
                  size: "sm",
                  checked: selected.has(row),
                  onChange: (chk) => toggleSelect(row, chk),
                  "aria-label": `Select row ${rIdx + 1}`
                }
              ) }),
              columns.map((c, cIdx) => {
                const getter = typeof c.accessor === "function" ? c.accessor : (item) => item[c.accessor];
                const content = c.render ? c.render(row, rIdx) : c.accessor !== void 0 ? getter(row) : null;
                return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Td, { $align: c.align ?? "left", children: content }, cIdx);
              })
            ] }, rIdx)) })
          ]
        }
      )
    }
  );
}
var Table_default = Table;

// src/components/widgets/Markdown.tsx
var import_jsx_runtime28 = require("react/jsx-runtime");
var renderInline = (tokens) => {
  if (!tokens) return null;
  return tokens.map((t, i) => {
    switch (t.type) {
      case "strong":
        return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("strong", { children: renderInline(t.tokens) }, i);
      case "em":
        return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("em", { children: renderInline(t.tokens) }, i);
      case "codespan":
        return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("code", { children: t.text }, i);
      case "link":
        return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("a", { href: t.href, title: t.title, children: renderInline(t.tokens) }, i);
      case "image":
        return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
          Image_default,
          {
            src: t.href,
            alt: t.text,
            style: { maxWidth: "100%" }
          },
          i
        );
      case "text":
        return t.text;
      default:
        return t.raw || "";
    }
  });
};
var renderTokens = (tokens, codeBg) => tokens.map((t, i) => {
  switch (t.type) {
    case "heading":
      const variant = `h${t.depth}`;
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Typography_default, { variant, bold: true, children: renderInline(t.tokens) }, i);
    case "paragraph":
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Typography_default, { style: { margin: "0.5rem 0" }, children: renderInline(t.tokens) }, i);
    case "list":
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("ul", { style: { paddingLeft: "1.25rem" }, children: t.items.map((item, j) => /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("li", { children: renderInline(item.tokens) }, j)) }, i);
    case "code":
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
        Panel_default,
        {
          preset: "codePanel",
          background: codeBg,
          style: { margin: "0.5rem 0" },
          children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("code", { children: t.text })
        },
        i
      );
    case "table":
      const columns = t.header.map((h, idx) => ({
        header: renderInline(h.tokens),
        accessor: idx.toString()
      }));
      const data = t.rows.map((row) => {
        const obj = {};
        row.forEach((cell, idx) => {
          obj[idx] = cell.text;
        });
        return obj;
      });
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
        Table_default,
        {
          data,
          columns,
          constrainHeight: false
        },
        i
      );
    case "space":
      return null;
    default:
      return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Typography_default, { children: "raw" in t && t.raw || "" }, i);
  }
});
var Markdown = ({
  data,
  codeBackground,
  className,
  style,
  ...rest
}) => {
  const tokens = import_react24.default.useMemo(() => import_marked.marked.lexer(data), [data]);
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Stack_default, { ...rest, className, style, children: renderTokens(tokens, codeBackground) });
};
var Markdown_default = Markdown;

// src/components/KeyModal.tsx
var import_react25 = require("react");

// src/system/aiKeyStore.ts
var import_traditional4 = require("zustand/traditional");
var import_middleware = require("zustand/middleware");
var algo = { name: "AES-GCM", length: 256 };
async function deriveKey(passphrase, salt) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    enc.encode(passphrase),
    { name: "PBKDF2" },
    false,
    ["deriveKey"]
  );
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 12e4, hash: "SHA-256" },
    keyMaterial,
    algo,
    false,
    ["encrypt", "decrypt"]
  );
}
async function encrypt(plaintext, passphrase) {
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(passphrase, salt);
  const data = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    enc.encode(plaintext)
  );
  return btoa(
    JSON.stringify({ iv: [...iv], salt: [...salt], data: [...new Uint8Array(data)] })
  );
}
async function decrypt(cipherB64, passphrase) {
  const { iv, salt, data } = JSON.parse(atob(cipherB64));
  const key = await deriveKey(passphrase, new Uint8Array(salt));
  const dec = await crypto.subtle.decrypt(
    { name: "AES-GCM", iv: new Uint8Array(iv) },
    key,
    new Uint8Array(data)
  );
  return new TextDecoder().decode(dec);
}
var dynamicStorage = {
  getItem: (n) => localStorage.getItem(n) ?? sessionStorage.getItem(n),
  setItem: (n, v) => {
    try {
      const p = JSON.parse(v);
      if (p.state?.cipher) {
        localStorage.setItem(n, v);
        sessionStorage.removeItem(n);
        return;
      }
    } catch {
    }
    sessionStorage.setItem(n, v);
  },
  removeItem: (n) => {
    localStorage.removeItem(n);
    sessionStorage.removeItem(n);
  }
};
var useAIKey = (0, import_traditional4.createWithEqualityFn)()(
  (0, import_middleware.persist)(
    (set, get) => ({
      apiKey: null,
      provider: null,
      model: null,
      cipher: null,
      passphrase: null,
      setKey: async (k, provider, pass) => {
        if (pass) {
          const cipher = await encrypt(k, pass);
          set({ apiKey: k, provider, model: null, cipher, passphrase: pass });
        } else {
          set({ apiKey: k, provider, model: null, cipher: null, passphrase: null });
        }
      },
      setModel: (m) => set({ model: m }),
      applyPassphrase: async (pass) => {
        const { cipher } = get();
        if (!cipher) return false;
        try {
          const key = await decrypt(cipher, pass);
          set({ apiKey: key, passphrase: pass });
          return true;
        } catch {
          return false;
        }
      },
      clearKey: () => {
        dynamicStorage.removeItem("valet-ai-key");
        set({ apiKey: null, provider: null, model: null, cipher: null, passphrase: null });
      }
    }),
    {
      name: "valet-ai-key",
      storage: (0, import_middleware.createJSONStorage)(() => dynamicStorage),
      partialize: (s) => ({ cipher: s.cipher, provider: s.provider, model: s.model })
    }
  )
);
async function sendChat(messages, model, provider, apiKey, endpoint) {
  const state = useAIKey.getState();
  const key = apiKey ?? state.apiKey;
  const prov = provider ?? state.provider;
  const mdl = model ?? state.model ?? (prov === "anthropic" ? "claude-sonnet-4-20250514" : "gpt-4o");
  if (!key || !prov) throw new Error("No API key set yet");
  if (prov === "openai") {
    const url2 = endpoint ?? "https://api.openai.com/v1/chat/completions";
    const res2 = await fetch(url2, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${key}`
      },
      body: JSON.stringify({ model: mdl, messages })
    });
    if (!res2.ok) throw new Error(await res2.text());
    return res2.json();
  }
  const url = endpoint ?? "https://api.anthropic.com/v1/messages";
  let system;
  let msgs = messages;
  if (Array.isArray(messages) && messages[0]?.role === "system") {
    system = messages[0].content;
    msgs = messages.slice(1);
  }
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": key,
      "anthropic-version": "2023-06-01",
      "anthropic-dangerous-direct-browser-access": "true"
    },
    body: JSON.stringify({ model: mdl, system, messages: msgs, max_tokens: 1024 })
  });
  if (!res.ok) throw new Error(await res.text());
  const json = await res.json();
  return {
    choices: [
      {
        message: {
          role: json.role,
          content: Array.isArray(json.content) ? json.content.map((p) => p.text ?? "").join("") : ""
        }
      }
    ]
  };
}

// src/components/KeyModal.tsx
var import_jsx_runtime29 = require("react/jsx-runtime");
function KeyModal({ open, onClose }) {
  const { apiKey, provider, cipher, setKey, applyPassphrase, clearKey } = useAIKey();
  const [value, setValue] = (0, import_react25.useState)("");
  const [remember, setRemember] = (0, import_react25.useState)(false);
  const [passphrase, setPassphrase] = (0, import_react25.useState)("");
  const [prov, setProv] = (0, import_react25.useState)(provider ?? "openai");
  const [error, setError] = (0, import_react25.useState)("");
  const { theme } = useTheme();
  if (!open) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Modal_default, { open, onClose, children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Panel_default, { centered: true, compact: true, style: { maxWidth: 480 }, children: /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(Stack_default, { spacing: 1, children: [
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Typography_default, { variant: "h3", bold: true, children: cipher ? `Unlock ${prov === "anthropic" ? "Anthropic" : "OpenAI"} key` : "Paste your API key" }),
    !cipher && /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      "input",
      {
        style: { fontFamily: "monospace", width: "100%", padding: "0.5rem" },
        type: "password",
        placeholder: "sk-...",
        value,
        onChange: (e) => {
          setValue(e.target.value);
          if (error) setError("");
        }
      }
    ),
    (remember || cipher) && /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      "input",
      {
        type: "password",
        placeholder: "passphrase",
        value: passphrase,
        onChange: (e) => {
          setPassphrase(e.target.value);
          if (error) setError("");
        },
        style: { width: "100%", padding: "0.5rem" }
      }
    ),
    !cipher && /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
      "select",
      {
        value: prov,
        onChange: (e) => setProv(e.target.value),
        style: { width: "100%", padding: "0.5rem" },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("option", { value: "openai", children: "OpenAI" }),
          /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("option", { value: "anthropic", children: "Anthropic" })
        ]
      }
    ),
    error && /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Typography_default, { color: theme.colors.secondary, children: error }),
    !cipher && /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("label", { style: { display: "flex", alignItems: "center", gap: "0.5rem" }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
        "input",
        {
          type: "checkbox",
          checked: remember,
          onChange: (e) => setRemember(e.target.checked)
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Typography_default, { children: "remember this key (encrypted)" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
      Button_default,
      {
        fullWidth: true,
        disabled: cipher ? !passphrase : !value.trim() || remember && !passphrase,
        onClick: async () => {
          setError("");
          if (cipher) {
            const ok = await applyPassphrase(passphrase);
            if (!ok) {
              setError("Incorrect passphrase");
              return;
            }
          } else {
            await setKey(
              value.trim(),
              prov,
              remember ? passphrase : void 0
            );
          }
          onClose?.();
        },
        children: "Save & Continue"
      }
    ),
    (cipher || apiKey) && /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Button_default, { variant: "outlined", fullWidth: true, onClick: () => {
      clearKey();
      onClose?.();
    }, children: "Delete stored key" })
  ] }) }) });
}

// src/components/widgets/LLMChat.tsx
var import_jsx_runtime30 = require("react/jsx-runtime");
var models = {
  openai: ["gpt-4o", "gpt-4-turbo", "gpt-3.5-turbo"],
  anthropic: [
    "claude-sonnet-4-20250514"
  ]
};
var Wrapper8 = styled("div")`
  display: flex;
  flex-direction: column;
  gap: ${({ $gap }) => $gap};
`;
var Messages = styled("div")`
  display: flex;
  flex-direction: column;
  gap: ${({ $gap }) => $gap};
`;
var Row = styled("div")`
  display: flex;
  align-items: center;
  justify-content: ${({ $from }) => $from === "user" ? "flex-end" : "flex-start"};
  padding-left: ${({ $left }) => $left};
  padding-right: ${({ $right }) => $right};
`;
var Bar3 = styled("div")`
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.5rem 1rem;
  background: ${({ $bg }) => $bg};
  color: ${({ $text }) => $text};
  & > * {
    padding: ${({ $gap }) => $gap};
  }
`;
var typingDot = keyframes`
  0%, 80%, 100% { opacity: 0.3; transform: translateY(0); }
  40% { opacity: 1; transform: translateY(-0.1rem); }
`;
var fadeIn = keyframes`
  from { opacity: 0; transform: translateY(0.25rem); }
  to   { opacity: 1; transform: translateY(0); }
`;
var Typing = styled("div")`
  display: flex;
  align-items: center;
  gap: 0.25rem;
  & span {
    width: 0.4rem;
    height: 0.4rem;
    border-radius: 50%;
    background: ${({ $color }) => $color};
    animation: ${typingDot} 1s infinite;
  }
  & span:nth-child(2) { animation-delay: 0.2s; }
  & span:nth-child(3) { animation-delay: 0.4s; }
`;
var LLMChat = ({
  messages,
  onSend,
  userAvatar,
  systemAvatar,
  placeholder = "Message\u2026",
  disableInput = false,
  constrainHeight = true,
  apiKey: propKey,
  provider: propProvider,
  model: propModel,
  onModelChange,
  preset: p,
  className,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  const surface = useSurface(
    (s) => ({
      element: s.element,
      width: s.width,
      height: s.height,
      registerChild: s.registerChild,
      unregisterChild: s.unregisterChild
    }),
    import_shallow6.shallow
  );
  const portrait = surface.height > surface.width;
  const wrapRef = (0, import_react26.useRef)(null);
  const uniqueId = (0, import_react26.useId)();
  const [maxHeight, setMaxHeight] = (0, import_react26.useState)();
  const [shouldConstrain, setShouldConstrain] = (0, import_react26.useState)(false);
  const constraintRef = (0, import_react26.useRef)(false);
  const [text, setText] = (0, import_react26.useState)("");
  const {
    apiKey: storeKey,
    provider: storeProv,
    model: storeModel,
    setModel
  } = useAIKey();
  const [showKeyModal, setShowKeyModal] = (0, import_react26.useState)(false);
  const key = propKey ?? storeKey;
  const provider = propProvider ?? storeProv;
  const [model, setModelLocal] = (0, import_react26.useState)(
    propModel ?? storeModel ?? (provider ? models[provider][0] : "")
  );
  (0, import_react26.useEffect)(() => {
    if (propModel) setModelLocal(propModel);
  }, [propModel]);
  (0, import_react26.useEffect)(() => {
    if (!propModel && provider) {
      const m = storeModel ?? models[provider][0];
      setModelLocal(m);
    }
  }, [provider, storeModel, propModel]);
  const handleModelChange = (m) => {
    if (!propModel) {
      setModelLocal(m);
      setModel(m);
    }
    onModelChange?.(m);
  };
  const calcCutoff = () => {
    if (typeof document === "undefined") return 32;
    const fs = parseFloat(
      getComputedStyle(document.documentElement).fontSize
    );
    return (isNaN(fs) ? 16 : fs) * 2;
  };
  const update = () => {
    const node = wrapRef.current;
    const surfEl = surface.element;
    if (!node || !surfEl) return;
    const sRect = surfEl.getBoundingClientRect();
    const nRect = node.getBoundingClientRect();
    const top = Math.round(nRect.top - sRect.top + surfEl.scrollTop);
    const bottomSpace = Math.round(
      surfEl.scrollHeight - (nRect.bottom - sRect.top + surfEl.scrollTop)
    );
    const available = Math.round(surface.height - top - bottomSpace);
    const cutoff = calcCutoff();
    const next = available >= cutoff;
    if (next) {
      if (!constraintRef.current) {
        surfEl.scrollTop = 0;
        surfEl.scrollLeft = 0;
      }
      constraintRef.current = true;
      setShouldConstrain(true);
      setMaxHeight(Math.max(0, available));
    } else {
      constraintRef.current = false;
      setShouldConstrain(false);
      setMaxHeight(void 0);
    }
  };
  (0, import_react26.useEffect)(() => {
    if (!constrainHeight) {
      constraintRef.current = false;
      setShouldConstrain(false);
      setMaxHeight(void 0);
    } else {
      constraintRef.current = false;
    }
  }, [constrainHeight]);
  (0, import_react26.useLayoutEffect)(() => {
    if (!constrainHeight || !wrapRef.current || !surface.element) return;
    const node = wrapRef.current;
    surface.registerChild(uniqueId, node, update);
    const ro = new ResizeObserver(update);
    ro.observe(node);
    update();
    return () => {
      surface.unregisterChild(uniqueId);
      ro.disconnect();
    };
  }, [constrainHeight, surface.element]);
  (0, import_react26.useLayoutEffect)(() => {
    if (!constrainHeight || !wrapRef.current || !surface.element) return;
    update();
  }, [constrainHeight, surface.height, surface.element]);
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!text.trim()) return;
    const msg = { role: "user", content: text.trim() };
    onSend?.(msg);
    setText("");
  };
  const presetClasses = p ? preset(p) : "";
  const cls = [presetClasses, className].filter(Boolean).join(" ") || void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [
    !propKey && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(KeyModal, { open: showKeyModal, onClose: () => setShowKeyModal(false) }),
    /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(
      Panel_default,
      {
        ...rest,
        compact: true,
        fullWidth: true,
        variant: "alt",
        style,
        className: cls,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(Bar3, { $bg: theme.colors.secondary, $text: theme.colors.secondaryText, $gap: theme.spacing(0.5), children: [
            provider && key ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
              Select_default,
              {
                size: "sm",
                value: model,
                onChange: (v) => handleModelChange(v),
                children: models[provider].map((m) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(Select_default.Option, { value: m, children: m }, m))
              }
            ) : /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("span", {}),
            /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(
              "span",
              {
                style: { display: "flex", alignItems: "center", cursor: "pointer", gap: theme.spacing(0.5) },
                onClick: () => !propKey && setShowKeyModal(true),
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(Typography_default, { variant: "subtitle", children: key ? "Connected" : "Disconnected" }),
                  /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
                    IconButton_default,
                    {
                      icon: key ? "carbon:checkmark" : "carbon:circle-dash",
                      "aria-label": "Set API key"
                    }
                  )
                ]
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(Wrapper8, { ref: wrapRef, $gap: theme.spacing(3), style: { overflow: "hidden" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
              Messages,
              {
                $gap: theme.spacing(1.5),
                style: shouldConstrain ? { overflowY: "auto", maxHeight } : void 0,
                children: messages.filter((m) => m.role !== "system").map((m, i) => {
                  const sidePad = portrait ? theme.spacing(8) : theme.spacing(24);
                  const avatarPad = theme.spacing(1);
                  return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(
                    Row,
                    {
                      $from: m.role,
                      $left: m.role === "user" ? sidePad : avatarPad,
                      $right: m.role === "user" ? avatarPad : sidePad,
                      children: [
                        m.role !== "user" && systemAvatar && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
                          Avatar_default,
                          {
                            src: systemAvatar,
                            size: "s",
                            variant: "outline",
                            style: { marginRight: theme.spacing(1) }
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(
                          Panel_default,
                          {
                            compact: true,
                            variant: "main",
                            background: m.role === "user" ? theme.colors.primary : void 0,
                            style: {
                              maxWidth: "100%",
                              width: "fit-content",
                              borderRadius: theme.spacing(0.5),
                              animation: m.animate ? `${fadeIn} 0.2s ease-out` : void 0
                            },
                            children: [
                              m.name && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(Typography_default, { variant: "subtitle", bold: true, children: m.name }),
                              m.typing ? /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(Typing, { $color: m.role === "user" ? theme.colors.primaryText : theme.colors.text, children: [
                                /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("span", {}),
                                /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("span", {}),
                                /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("span", {})
                              ] }) : m.role === "assistant" ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(Markdown_default, { data: m.content, codeBackground: theme.colors.background }) : /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(Typography_default, { children: m.content })
                            ]
                          }
                        ),
                        m.role === "user" && userAvatar && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
                          Avatar_default,
                          {
                            src: userAvatar,
                            size: "s",
                            variant: "outline",
                            style: { marginLeft: theme.spacing(1) }
                          }
                        )
                      ]
                    },
                    i
                  );
                })
              }
            ),
            !disableInput && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("form", { onSubmit: handleSubmit, style: { width: "100%" }, children: /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(Stack_default, { direction: "row", spacing: 1, compact: true, children: [
              /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
                TextField_default,
                {
                  as: "textarea",
                  name: "chat-message",
                  value: text,
                  onChange: (e) => setText(e.target.value),
                  onKeyDown: (e) => {
                    if (e.key === "Enter" && !e.shiftKey) {
                      e.preventDefault();
                      handleSubmit(e);
                    }
                  },
                  rows: 1,
                  placeholder,
                  fullWidth: true
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(IconButton_default, { icon: "carbon:send", type: "submit", "aria-label": "Send" })
            ] }) })
          ] })
        ]
      }
    )
  ] });
};

// src/components/widgets/RichChat.tsx
var import_react27 = require("react");
var import_shallow7 = require("zustand/shallow");
var import_jsx_runtime31 = require("react/jsx-runtime");
var Wrapper9 = styled("div")`
  display: flex;
  flex-direction: column;
  gap: ${({ $gap }) => $gap};
`;
var Messages2 = styled("div")`
  display: flex;
  flex-direction: column;
  gap: ${({ $gap }) => $gap};
`;
var Row2 = styled("div")`
  display: flex;
  align-items: center;
  justify-content: ${({ $from }) => $from === "user" ? "flex-end" : "flex-start"};
  padding-left: ${({ $left }) => $left};
  padding-right: ${({ $right }) => $right};
`;
var typingDot2 = keyframes`
  0%, 80%, 100% { opacity: 0.3; transform: translateY(0); }
  40% { opacity: 1; transform: translateY(-0.1rem); }
`;
var fadeIn2 = keyframes`
  from { opacity: 0; transform: translateY(0.25rem); }
  to   { opacity: 1; transform: translateY(0); }
`;
var Typing2 = styled("div")`
  display: flex;
  align-items: center;
  gap: 0.25rem;
  & span {
    width: 0.4rem;
    height: 0.4rem;
    border-radius: 50%;
    background: ${({ $color }) => $color};
    animation: ${typingDot2} 1s infinite;
  }
  & span:nth-child(2) { animation-delay: 0.2s; }
  & span:nth-child(3) { animation-delay: 0.4s; }
`;
var RichChat = ({
  messages,
  onSend,
  onFormSubmit,
  userAvatar,
  systemAvatar,
  placeholder = "Message\u2026",
  disableInput = false,
  constrainHeight = true,
  preset: p,
  className,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  const surface = useSurface(
    (s) => ({
      element: s.element,
      width: s.width,
      height: s.height,
      registerChild: s.registerChild,
      unregisterChild: s.unregisterChild
    }),
    import_shallow7.shallow
  );
  const portrait = surface.height > surface.width;
  const wrapRef = (0, import_react27.useRef)(null);
  const uniqueId = (0, import_react27.useId)();
  const [maxHeight, setMaxHeight] = (0, import_react27.useState)();
  const [shouldConstrain, setShouldConstrain] = (0, import_react27.useState)(false);
  const constraintRef = (0, import_react27.useRef)(false);
  const [text, setText] = (0, import_react27.useState)("");
  const inputDisabled = disableInput || messages.some((m) => m.form);
  const calcCutoff = () => {
    if (typeof document === "undefined") return 32;
    const fs = parseFloat(
      getComputedStyle(document.documentElement).fontSize
    );
    return (isNaN(fs) ? 16 : fs) * 2;
  };
  const update = () => {
    const node = wrapRef.current;
    const surfEl = surface.element;
    if (!node || !surfEl) return;
    const sRect = surfEl.getBoundingClientRect();
    const nRect = node.getBoundingClientRect();
    const top = Math.round(nRect.top - sRect.top + surfEl.scrollTop);
    const bottomSpace = Math.round(
      surfEl.scrollHeight - (nRect.bottom - sRect.top + surfEl.scrollTop)
    );
    const available = Math.round(surface.height - top - bottomSpace);
    const cutoff = calcCutoff();
    const next = available >= cutoff;
    if (next) {
      if (!constraintRef.current) {
        surfEl.scrollTop = 0;
        surfEl.scrollLeft = 0;
      }
      constraintRef.current = true;
      setShouldConstrain(true);
      setMaxHeight(Math.max(0, available));
    } else {
      constraintRef.current = false;
      setShouldConstrain(false);
      setMaxHeight(void 0);
    }
  };
  (0, import_react27.useEffect)(() => {
    if (!constrainHeight) {
      constraintRef.current = false;
      setShouldConstrain(false);
      setMaxHeight(void 0);
    } else {
      constraintRef.current = false;
    }
  }, [constrainHeight]);
  (0, import_react27.useLayoutEffect)(() => {
    if (!constrainHeight || !wrapRef.current || !surface.element) return;
    const node = wrapRef.current;
    surface.registerChild(uniqueId, node, update);
    const ro = new ResizeObserver(update);
    ro.observe(node);
    update();
    return () => {
      surface.unregisterChild(uniqueId);
      ro.disconnect();
    };
  }, [constrainHeight, surface.element]);
  (0, import_react27.useLayoutEffect)(() => {
    if (!constrainHeight || !wrapRef.current || !surface.element) return;
    update();
  }, [constrainHeight, surface.height, surface.element]);
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!text.trim()) return;
    const msg = { role: "user", content: text.trim() };
    onSend?.(msg);
    setText("");
  };
  const presetClasses = p ? preset(p) : "";
  const cls = [presetClasses, className].filter(Boolean).join(" ") || void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    Panel_default,
    {
      ...rest,
      compact: true,
      fullWidth: true,
      variant: "alt",
      style,
      className: cls,
      children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Wrapper9, { ref: wrapRef, $gap: theme.spacing(3), style: { overflow: "hidden" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
          Messages2,
          {
            $gap: theme.spacing(1.5),
            style: shouldConstrain ? { overflowY: "auto", maxHeight } : void 0,
            children: messages.filter((m) => m.role !== "system").map((m, i) => {
              const sidePad = portrait ? theme.spacing(8) : theme.spacing(24);
              const avatarPad = theme.spacing(1);
              const content = typeof m.content === "string" ? m.role === "assistant" ? /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
                Markdown_default,
                {
                  data: m.content,
                  codeBackground: theme.colors.background
                }
              ) : /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Typography_default, { children: m.content }) : m.content;
              const Form = m.form;
              return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(
                Row2,
                {
                  $from: m.role,
                  $left: m.role === "user" ? sidePad : avatarPad,
                  $right: m.role === "user" ? avatarPad : sidePad,
                  children: [
                    m.role !== "user" && systemAvatar && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
                      Avatar_default,
                      {
                        src: systemAvatar,
                        size: "s",
                        variant: "outline",
                        style: { marginRight: theme.spacing(1) }
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
                      Panel_default,
                      {
                        compact: true,
                        variant: "main",
                        background: m.role === "user" ? theme.colors.primary : void 0,
                        style: {
                          maxWidth: "100%",
                          width: "fit-content",
                          borderRadius: theme.spacing(0.5),
                          animation: m.animate ? `${fadeIn2} 0.2s ease-out` : void 0,
                          position: "relative"
                        },
                        children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)("div", { children: [
                          m.name && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Typography_default, { variant: "subtitle", bold: true, children: m.name }),
                          m.typing ? /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Typing2, { $color: m.role === "user" ? theme.colors.primaryText : theme.colors.text, children: [
                            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("span", {}),
                            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("span", {}),
                            /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("span", {})
                          ] }) : content,
                          Form && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(Form, { onSubmit: (v) => onFormSubmit?.(v, i) })
                        ] })
                      }
                    ),
                    m.role === "user" && userAvatar && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
                      Avatar_default,
                      {
                        src: userAvatar,
                        size: "s",
                        variant: "outline",
                        style: { marginLeft: theme.spacing(1) }
                      }
                    )
                  ]
                },
                i
              );
            })
          }
        ),
        !inputDisabled && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("form", { onSubmit: handleSubmit, style: { width: "100%" }, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(Stack_default, { direction: "row", spacing: 1, compact: true, children: [
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
            TextField_default,
            {
              as: "textarea",
              name: "chat-message",
              value: text,
              onChange: (e) => setText(e.target.value),
              onKeyDown: (e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();
                  handleSubmit(e);
                }
              },
              rows: 1,
              placeholder,
              fullWidth: true
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(IconButton_default, { icon: "carbon:send", type: "submit", "aria-label": "Send" })
        ] }) })
      ] })
    }
  );
};

// src/components/layout/Drawer.tsx
var import_react28 = require("react");
var import_react_dom3 = require("react-dom");
var import_shallow8 = require("zustand/shallow");
var import_jsx_runtime32 = require("react/jsx-runtime");
var Backdrop2 = styled("div")`
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.55);
  backdrop-filter: blur(2px);
  opacity: ${({ $fade }) => $fade ? 0 : 1};
  transition: opacity 200ms ease;
  z-index: 9998;
`;
var Panel2 = styled("div")`
  position: fixed;
  z-index: ${({ $persistent }) => $persistent ? 9998 : 9999};
  display: flex;
  flex-direction: column;
  overflow-y: ${({ $anchor }) => $anchor === "left" || $anchor === "right" ? "auto" : "visible"};
  overflow-x: ${({ $anchor }) => $anchor === "top" || $anchor === "bottom" ? "auto" : "visible"};
  background: ${({ $bg }) => $bg};
  color: ${({ $text }) => $text};
  box-shadow: ${({ $adaptive }) => $adaptive ? "none" : "0 4px 16px rgba(0, 0, 0, 0.3)"};
  ${({ $anchor, $primary }) => $anchor === "left" ? `border-right:0.25rem solid ${$primary};` : $anchor === "right" ? `border-left:0.25rem solid ${$primary};` : $anchor === "top" ? `border-bottom:0.25rem solid ${$primary};` : `border-top:0.25rem solid ${$primary};`}
  ${({ $anchor, $size }) => $anchor === "left" || $anchor === "right" ? `width:${$size}; height:100%;` : `height:${$size}; width:100%;`}
  ${({ $anchor }) => $anchor === "left" ? "top:0; left:0;" : $anchor === "right" ? "top:0; right:0;" : $anchor === "top" ? "top:0; left:0;" : "bottom:0; left:0;"}
  transform: ${({ $anchor, $fade, $persistent }) => $persistent ? "none" : $anchor === "left" ? `translateX(${$fade ? "-100%" : "0"})` : $anchor === "right" ? `translateX(${$fade ? "100%" : "0"})` : $anchor === "top" ? `translateY(${$fade ? "-100%" : "0"})` : `translateY(${$fade ? "100%" : "0"})`};
  transition: ${({ $persistent }) => $persistent ? "none" : "transform 200ms ease"};
`;
var Drawer = ({
  open: controlledOpen,
  defaultOpen = false,
  anchor = "left",
  onClose,
  size = "16rem",
  disableBackdropClick = false,
  disableEscapeKeyDown = false,
  persistent = false,
  adaptive = false,
  toggleIcon = "mdi:menu",
  closeIcon = "mdi:close",
  children,
  preset: presetKey
}) => {
  const { theme } = useTheme();
  const { width, height, element } = useSurface(
    (s) => ({ width: s.width, height: s.height, element: s.element }),
    import_shallow8.shallow
  );
  const surfOffset = element ? parseFloat(window.getComputedStyle(element).marginTop || "0") : 0;
  const presetClasses = presetKey ? preset(presetKey) : "";
  const toggleBg = withAlpha(theme.colors.primary, 0.7);
  const portrait = height > width;
  const adaptiveMode = adaptive && (anchor === "left" || anchor === "right");
  const orientationPersistent = adaptiveMode && !portrait;
  const persistentEffective = persistent || orientationPersistent;
  const uncontrolled = controlledOpen === void 0;
  const [openState, setOpenState] = (0, import_react28.useState)(defaultOpen);
  const open = persistentEffective ? true : uncontrolled ? openState : controlledOpen;
  const [fade, setFade] = (0, import_react28.useState)(true);
  (0, import_react28.useEffect)(() => {
    if (orientationPersistent) setOpenState(true);
    else if (adaptiveMode && portrait) setOpenState(false);
  }, [orientationPersistent, adaptiveMode, portrait]);
  const requestClose = (0, import_react28.useCallback)(() => {
    if (orientationPersistent) return;
    if (uncontrolled) setOpenState(false);
    onClose?.();
  }, [orientationPersistent, uncontrolled, onClose]);
  (0, import_react28.useLayoutEffect)(() => {
    if (persistentEffective || !open) return;
    setFade(false);
    const handleKeyDown = (e) => {
      if (e.key === "Escape" && !disableEscapeKeyDown) {
        e.stopPropagation();
        requestClose();
      }
    };
    document.addEventListener("keydown", handleKeyDown, true);
    return () => {
      document.removeEventListener("keydown", handleKeyDown, true);
      setFade(true);
    };
  }, [open, persistentEffective, disableEscapeKeyDown, requestClose]);
  const handleBackdropClick = (e) => {
    if (persistentEffective || disableBackdropClick) return;
    if (e.target === e.currentTarget) requestClose();
  };
  (0, import_react28.useLayoutEffect)(() => {
    const node = element;
    if (!node) return;
    const horizontal = anchor === "left" || anchor === "right";
    if (persistentEffective && horizontal) {
      const px = typeof size === "number" ? `${size}px` : size;
      const prop = anchor === "left" ? "marginLeft" : "marginRight";
      const prev = node.style[prop];
      node.style[prop] = px;
      return () => {
        node.style[prop] = prev;
      };
    }
    return;
  }, [element, persistentEffective, anchor, size]);
  if (!open && !persistentEffective) {
    if (adaptiveMode && portrait) {
      return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
        IconButton,
        {
          icon: toggleIcon,
          onClick: () => setOpenState(true),
          style: {
            position: "fixed",
            top: `calc(${theme.spacing(1)} + ${surfOffset}px)`,
            [anchor]: theme.spacing(1),
            zIndex: 9999,
            background: toggleBg
          },
          "aria-label": "Open drawer"
        }
      );
    }
    return null;
  }
  const drawerElement = /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(import_jsx_runtime32.Fragment, { children: [
    !persistentEffective && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Backdrop2, { $fade: fade, onClick: handleBackdropClick }),
    /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(
      Panel2,
      {
        $anchor: anchor,
        $fade: fade,
        $size: typeof size === "number" ? `${size}px` : size,
        $bg: theme.colors.background,
        $text: theme.colors.text,
        $primary: theme.colors.primary,
        $persistent: persistentEffective,
        $adaptive: adaptiveMode,
        className: presetClasses,
        style: anchor === "left" || anchor === "right" || anchor === "top" ? { top: `${surfOffset}px` } : void 0,
        children: [
          adaptiveMode && portrait && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
            "div",
            {
              style: {
                alignSelf: anchor === "left" ? "flex-end" : "flex-start",
                padding: theme.spacing(0.5)
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
                IconButton,
                {
                  icon: closeIcon,
                  size: "sm",
                  variant: "outlined",
                  onClick: requestClose,
                  "aria-label": "Close drawer"
                }
              )
            }
          ),
          children
        ]
      }
    )
  ] });
  return (0, import_react_dom3.createPortal)(drawerElement, document.body);
};

// src/components/fields/DateSelector.tsx
var import_react29 = require("react");
var import_jsx_runtime33 = require("react/jsx-runtime");
var Wrapper10 = styled("div")`
  display: inline-block;
  padding: 0.5rem;
  background: ${({ $bg }) => $bg};
  color: ${({ $text }) => $text};
  border-radius: 4px;
  user-select: none;
`;
var Header2 = styled("div")`
  display: flex;
  align-items: center;
  gap: ${({ $gap }) => $gap};
  margin-bottom: 0.5rem;
`;
var Grid2 = styled("div")`
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 0.25rem;
`;
var DayLabel = styled("div")`
  font-size: 0.75rem;
  text-align: center;
  opacity: 0.8;
`;
var Cell = styled("button")`
  padding: 0.25rem 0;
  border: none;
  background: ${({ $start, $end, $inRange, $primary, $secondary, $rangeBg }) => $start ? $primary : $end ? $secondary : $inRange ? $rangeBg : "transparent"};
  color: inherit;
  border-radius: 4px;
  cursor: pointer;
  font: inherit;
  font-weight: ${({ $start, $end }) => $start || $end ? "bold" : "inherit"};
  height: 2rem;
  &:hover:not(:disabled) { filter: brightness(1.2); }
  &:disabled { opacity: 0.4; cursor: default; }
`;
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var days = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
var DateSelector = ({
  value,
  defaultValue,
  onChange,
  range = false,
  endValue,
  defaultEndValue,
  onRangeChange,
  name,
  minDate: minDateProp,
  maxDate: maxDateProp,
  preset: p,
  className,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  let form = null;
  try {
    form = useForm();
  } catch {
  }
  const formVal = form && name ? form.values[name] : void 0;
  const controlled = value !== void 0 || formVal !== void 0;
  const parseDate = (v) => v ? /* @__PURE__ */ new Date(v + "T00:00") : /* @__PURE__ */ new Date();
  const initialStart = value ?? formVal ?? defaultValue;
  const initialEnd = endValue ?? defaultEndValue ?? initialStart;
  const [startInt, setStartInt] = (0, import_react29.useState)(parseDate(initialStart));
  const [endInt, setEndInt] = (0, import_react29.useState)(parseDate(initialEnd));
  const today = /* @__PURE__ */ new Date();
  const min = minDateProp ? parseDate(minDateProp) : new Date(today.getFullYear() - 120, 0, 1);
  const max = maxDateProp ? parseDate(maxDateProp) : new Date(today.getFullYear() + 120, 11, 31);
  const minYear = min.getFullYear();
  const maxYear = max.getFullYear();
  const startDate = controlled ? parseDate(value ?? formVal) : startInt;
  const endDate = range ? endValue !== void 0 ? parseDate(endValue) : endInt : startDate;
  const [viewYear, setViewYear] = (0, import_react29.useState)(startDate.getFullYear());
  const [viewMonth, setViewMonth] = (0, import_react29.useState)(startDate.getMonth());
  const years = Array.from({ length: maxYear - minYear + 1 }, (_, i) => minYear + i);
  const minMonth = min.getMonth();
  const maxMonth = max.getMonth();
  const firstMonth = viewYear === minYear ? minMonth : 0;
  const lastMonth = viewYear === maxYear ? maxMonth : 11;
  const months = Array.from({ length: lastMonth - firstMonth + 1 }, (_, i) => firstMonth + i);
  const startDay = new Date(viewYear, viewMonth, 1).getDay();
  const daysInMonth = new Date(viewYear, viewMonth + 1, 0).getDate();
  const commit = (d) => {
    const iso = new Date(viewYear, viewMonth, d).toISOString().slice(0, 10);
    if (!controlled) setStartInt(new Date(viewYear, viewMonth, d));
    if (form && name) form.setField(name, iso);
    onChange?.(iso);
  };
  const commitRange = (d) => {
    const clicked = new Date(viewYear, viewMonth, d);
    let start = startDate;
    let end = endDate;
    if (start.getTime() !== end.getTime()) {
      start = clicked;
      end = clicked;
    } else {
      if (clicked < start) {
        start = clicked;
      } else {
        end = clicked;
      }
      if (start > end) {
        const tmp = start;
        start = end;
        end = tmp;
      }
    }
    if (!controlled) setStartInt(start);
    if (endValue === void 0) setEndInt(end);
    onRangeChange?.(start.toISOString().slice(0, 10), end.toISOString().slice(0, 10));
  };
  const changeMonth = (delta) => {
    setViewMonth((m) => {
      let next = m + delta;
      let yr = viewYear;
      while (next < 0) {
        next += 12;
        yr--;
      }
      while (next > 11) {
        next -= 12;
        yr++;
      }
      const start = new Date(yr, next, 1);
      const end = new Date(yr, next + 1, 0);
      if (end < min || start > max) return m;
      setViewYear(yr);
      return next;
    });
  };
  const presetCls = p ? preset(p) : "";
  const cls = [presetCls, className].filter(Boolean).join(" ") || void 0;
  const rangeBg = toHex(
    mix(toRgb(theme.colors.primary), toRgb(theme.colors.background), 0.25)
  );
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(
    Wrapper10,
    {
      ...rest,
      $bg: theme.colors.backgroundAlt,
      $text: theme.colors.text,
      className: cls,
      style,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(Header2, { $gap: theme.spacing(1), children: [
          /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("div", { style: { display: "flex", gap: theme.spacing(0.5) }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
              IconButton,
              {
                size: "sm",
                variant: "outlined",
                icon: "mdi:chevron-double-left",
                "aria-label": "Previous year",
                onClick: () => {
                  const yr = viewYear - 1;
                  let m = viewMonth;
                  if (yr === minYear && m < minMonth) m = minMonth;
                  setViewYear(yr);
                  setViewMonth(m);
                },
                disabled: new Date(viewYear - 1, 11, 31) < min
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
              IconButton,
              {
                size: "sm",
                variant: "outlined",
                icon: "mdi:chevron-left",
                "aria-label": "Previous month",
                onClick: () => changeMonth(-1),
                disabled: new Date(viewYear, viewMonth, 0) < min
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(
            "div",
            {
              style: {
                display: "flex",
                gap: theme.spacing(0.5),
                flex: 1,
                alignItems: "center"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
                  Select,
                  {
                    size: "xs",
                    value: viewMonth,
                    onChange: (v) => setViewMonth(Number(v)),
                    style: { flex: 1 },
                    children: months.map((idx) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Select.Option, { value: idx, children: monthNames[idx] }, monthNames[idx]))
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
                  Select,
                  {
                    size: "xs",
                    value: viewYear,
                    onChange: (v) => {
                      const yr = Number(v);
                      let m = viewMonth;
                      if (yr === minYear && m < minMonth) m = minMonth;
                      if (yr === maxYear && m > maxMonth) m = maxMonth;
                      setViewYear(yr);
                      setViewMonth(m);
                    },
                    style: { flex: 1 },
                    children: years.map((y) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Select.Option, { value: y, children: y }, y))
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("div", { style: { display: "flex", gap: theme.spacing(0.5) }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
              IconButton,
              {
                size: "sm",
                variant: "outlined",
                icon: "mdi:chevron-right",
                "aria-label": "Next month",
                onClick: () => changeMonth(1),
                disabled: new Date(viewYear, viewMonth + 1, 1) > max
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
              IconButton,
              {
                size: "sm",
                variant: "outlined",
                icon: "mdi:chevron-double-right",
                "aria-label": "Next year",
                onClick: () => {
                  const yr = viewYear + 1;
                  let m = viewMonth;
                  if (yr === maxYear && m > maxMonth) m = maxMonth;
                  setViewYear(yr);
                  setViewMonth(m);
                },
                disabled: new Date(viewYear + 1, 0, 1) > max
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(Grid2, { children: [
          days.map((d) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(DayLabel, { children: d }, d)),
          Array.from({ length: startDay }).map((_, i) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("span", {}, `blank-${i}`)),
          Array.from({ length: daysInMonth }).map((_, i) => {
            const day = i + 1;
            const date = new Date(viewYear, viewMonth, day);
            const disabled = date < min || date > max;
            const startSel = startDate.getFullYear() === viewYear && startDate.getMonth() === viewMonth && startDate.getDate() === day;
            const endSel = range && endDate.getFullYear() === viewYear && endDate.getMonth() === viewMonth && endDate.getDate() === day;
            const inRange = range && date > startDate && date < endDate;
            return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
              Cell,
              {
                $start: startSel,
                $end: !!endSel && !startSel,
                $inRange: !!inRange,
                $primary: theme.colors.primary,
                $secondary: theme.colors.secondary,
                $rangeBg: rangeBg,
                onClick: () => !disabled && (range ? commitRange(day) : commit(day)),
                disabled,
                children: day
              },
              day
            );
          })
        ] })
      ]
    }
  );
};

// src/components/layout/List.tsx
var import_react30 = require("react");
var import_jsx_runtime34 = require("react/jsx-runtime");
var EMPTY_IMG = (() => {
  const img = new Image();
  img.src = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
  return img;
})();
var Root6 = styled("ul")`
  list-style: none;
  margin: 0;
  padding: 0;
  border: 1px solid ${({ $border }) => $border};

  li {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    padding: 0.5rem 0.75rem;
    border-bottom: 1px solid ${({ $border }) => $border};
    cursor: grab;
    user-select: none;
    transition: background 120ms ease;
  }
  li:last-child { border-bottom: none; }

  /* Zebra stripes */
  ${({ $striped, $stripe }) => $striped && `li:nth-of-type(odd){background:${$stripe};}`}

  /* Hover + drag highlight (row AND its cells) */
  ${({ $hover, $hoverBg }) => $hover && `
      li:hover,
      li:hover > *,
      li[data-dragging="true"],
      li[data-dragging="true"] > * {
        background:${$hoverBg};
      }
    `}
`;
function List({
  data,
  getTitle,
  getSubtitle,
  striped = false,
  hoverable,
  onReorder,
  preset: p,
  className,
  style,
  ...rest
}) {
  const { theme } = useTheme();
  const stripeColor = stripe(theme.colors.background, theme.colors.text);
  const hoverBg = toHex(
    mix(toRgb(theme.colors.primary), toRgb(theme.colors.background), 0.25)
  );
  const enableHover = hoverable !== void 0 ? hoverable : !striped;
  const [items, setItems] = (0, import_react30.useState)(data);
  const dragFrom = (0, import_react30.useRef)(null);
  const [dragIdx, setDragIdx] = (0, import_react30.useState)(null);
  (0, import_react30.useEffect)(() => setItems(data), [data]);
  const handleDragStart = (idx) => (e) => {
    dragFrom.current = idx;
    setDragIdx(idx);
    e.dataTransfer.setDragImage(EMPTY_IMG, 0, 0);
    e.dataTransfer.effectAllowed = "move";
  };
  const handleDragOver = (idx) => (e) => {
    e.preventDefault();
    const from = dragFrom.current;
    if (from === null || from === idx) return;
    setItems((prev) => {
      const arr = [...prev];
      const [moved] = arr.splice(from, 1);
      arr.splice(idx, 0, moved);
      dragFrom.current = idx;
      return arr;
    });
    setDragIdx(idx);
  };
  const handleDragEnd = () => {
    if (dragFrom.current !== null) onReorder?.(items);
    dragFrom.current = null;
    setDragIdx(null);
  };
  const cls = [p ? preset(p) : "", className].filter(Boolean).join(" ") || void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
    Root6,
    {
      ...rest,
      $striped: striped,
      $hover: enableHover,
      $border: theme.colors.backgroundAlt,
      $stripe: stripeColor,
      $hoverBg: hoverBg,
      className: cls,
      style,
      children: items.map((item, idx) => /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(
        "li",
        {
          draggable: true,
          "data-dragging": dragIdx === idx || void 0,
          onDragStart: handleDragStart(idx),
          onDragOver: handleDragOver(idx),
          onDragEnd: handleDragEnd,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Typography, { variant: "body", bold: true, children: getTitle(item) }),
            getSubtitle && /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Typography, { variant: "subtitle", children: getSubtitle(item) })
          ]
        },
        idx
      ))
    }
  );
}

// src/components/widgets/Pagination.tsx
var import_jsx_runtime35 = require("react/jsx-runtime");
var Root7 = styled("nav")`
  display: flex;
  gap: 0.5rem;

  button {
    background: none;
    border: none;
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    color: ${({ $text }) => $text};
    font: inherit;
    line-height: 1;
  }

  button:disabled {
    opacity: 0.4;
    cursor: default;
  }
`;
var PageBtn = styled("button")`
  position: relative;
  font-weight: ${({ $active }) => $active ? 700 : 400};
  color: ${({ $active, $primary, $text }) => $active ? $primary : $text};

  &::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: -0.3rem;       /* hugs text baseline */
    height: 0.25rem;       /* thicker than normal underline */
    border-radius: 2px 2px 0 0;
    background: ${({ $active, $primary }) => $active ? $primary : "transparent"};
    transition: background 150ms ease;
  }
`;
var Pagination = ({
  count,
  page = 1,
  onChange,
  preset: p,
  className,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  const pages = Array.from({ length: count }, (_, i) => i + 1);
  const presetClass = p ? preset(p) : "";
  const mergedClass = [presetClass, className].filter(Boolean).join(" ") || void 0;
  const nav = (p2) => () => onChange?.(p2);
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(
    Root7,
    {
      ...rest,
      "aria-label": "pagination",
      $text: theme.colors.text,
      className: mergedClass,
      style,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
          "button",
          {
            onClick: nav(Math.max(1, page - 1)),
            disabled: page === 1,
            children: "Prev"
          }
        ),
        pages.map((n) => /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
          PageBtn,
          {
            onClick: nav(n),
            $active: n === page,
            $primary: theme.colors.primary,
            $text: theme.colors.text,
            "aria-current": n === page ? "page" : void 0,
            children: n
          },
          n
        )),
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
          "button",
          {
            onClick: nav(Math.min(count, page + 1)),
            disabled: page === count,
            children: "Next"
          }
        )
      ]
    }
  );
};

// src/components/widgets/Parallax.tsx
var import_react31 = require("react");
var import_jsx_runtime36 = require("react/jsx-runtime");
var ParallaxCtx = (0, import_react31.createContext)({ scrollY: 0, scrollX: 0 });
var useParallax = () => (0, import_react31.useContext)(ParallaxCtx);
var findScrollParent = (node) => {
  let el = node?.parentElement ?? null;
  while (el) {
    const { overflowY, overflowX } = getComputedStyle(el);
    if (/(auto|scroll)/.test(`${overflowY}${overflowX}`)) return el;
    el = el.parentElement;
  }
  return window;
};
var ParallaxScroll = ({
  children,
  trackX = false,
  preset: p,
  style,
  className,
  ...props
}) => {
  const selfRef = (0, import_react31.useRef)(null);
  const [state, setState] = (0, import_react31.useState)({ scrollY: 0, scrollX: 0 });
  (0, import_react31.useEffect)(() => {
    if (!selfRef.current) return;
    const scrollParent = findScrollParent(selfRef.current);
    let ticking = false;
    const onScroll = () => {
      if (ticking) return;
      ticking = true;
      requestAnimationFrame(() => {
        const y = scrollParent === window ? window.scrollY : scrollParent.scrollTop;
        const x = trackX ? scrollParent === window ? window.scrollX : scrollParent.scrollLeft : 0;
        setState({ scrollY: y, scrollX: x });
        ticking = false;
      });
    };
    onScroll();
    scrollParent.addEventListener("scroll", onScroll, { passive: true });
    return () => scrollParent.removeEventListener("scroll", onScroll);
  }, [trackX]);
  const presetClasses = p ? preset(p) : "";
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(ParallaxCtx.Provider, { value: state, children: /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
    "div",
    {
      ref: selfRef,
      className: [presetClasses, className].filter(Boolean).join(" "),
      style: { position: "relative", overflow: "hidden", ...style },
      ...props,
      children
    }
  ) });
};
var ParallaxLayer = ({
  children,
  speed = 0.5,
  axis = "y",
  preset: p,
  style,
  className,
  ...props
}) => {
  const { scrollY, scrollX } = useParallax();
  const offset = (0, import_react31.useMemo)(() => {
    const d = axis === "y" ? scrollY : scrollX;
    return d * (speed - 1);
  }, [scrollY, scrollX, speed, axis]);
  const transform = axis === "y" ? `translate3d(0, ${offset}px, 0)` : `translate3d(${offset}px, 0, 0)`;
  const presetClasses = p ? preset(p) : "";
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
    "div",
    {
      className: [presetClasses, className].filter(Boolean).join(" "),
      style: {
        position: "relative",
        willChange: "transform",
        transform,
        ...style
      },
      ...props,
      children
    }
  );
};
var ParallaxBackground = ({
  src,
  mediaType,
  poster,
  speed = 0.5,
  axis = "y",
  preset: p,
  className,
  style,
  loop = true,
  muted = true,
  autoPlay = true,
  preload = "auto",
  ...props
}) => {
  const guessedType = (0, import_react31.useMemo)(() => {
    if (mediaType) return mediaType;
    return /\.(webm|mp4|mov)$/i.test(src) ? "video" : "image";
  }, [mediaType, src]);
  const mediaRef = (0, import_react31.useRef)(null);
  (0, import_react31.useEffect)(() => {
    if (guessedType !== "video" || !("IntersectionObserver" in window)) return;
    const vid = mediaRef.current;
    if (!vid) return;
    const io = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          vid.play().catch(() => void 0);
        } else {
          vid.pause();
        }
      },
      { threshold: 0.1 }
    );
    io.observe(vid);
    return () => io.disconnect();
  }, [guessedType]);
  const presetClasses = p ? preset(p) : "";
  const mediaEl = guessedType === "video" ? /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
    "video",
    {
      ref: mediaRef,
      src,
      poster,
      loop,
      muted,
      playsInline: true,
      autoPlay,
      preload,
      style: { width: "100%", height: "100%", objectFit: "cover" }
    }
  ) : /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
    "img",
    {
      ref: mediaRef,
      src,
      loading: "lazy",
      alt: "",
      style: { width: "100%", height: "100%", objectFit: "cover" }
    }
  );
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
    ParallaxLayer,
    {
      speed,
      axis,
      preset: p,
      className: [presetClasses, className].filter(Boolean).join(" "),
      style: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none",
        // let UI on top be interactive
        ...style
      },
      ...props,
      children: mediaEl
    }
  );
};

// src/components/widgets/Snackbar.tsx
var import_react32 = require("react");
var import_shallow9 = require("zustand/shallow");
var import_jsx_runtime37 = require("react/jsx-runtime");
var SnackbarCtx = (0, import_react32.createContext)(null);
var useSnackbar = () => (0, import_react32.useContext)(SnackbarCtx);
var Root8 = styled("div")`
  position: fixed;
  left: 50%;
  bottom: ${({ $spacing }) => $spacing};
  transform: translateX(-50%)
    translateY(${({ $visible }) => $visible ? "0" : "0.75rem"});
  opacity: ${({ $visible }) => $visible ? 1 : 0};
  pointer-events: ${({ $visible }) => $visible ? "auto" : "none"};
  transition: opacity 200ms ease, transform 200ms ease;

  background: ${({ $bg }) => $bg};
  outline: 0.25rem solid ${({ $outline }) => $outline};
  border-radius: 0.375rem;
  padding: 0.5rem 1rem;
  max-width: 95vw;
  box-sizing: border-box;
  z-index: 1000;

  display: ${({ $flex }) => $flex ? "flex" : "block"};
  flex-direction: row;
  align-items: center;
  gap: ${({ $flex, $spacing }) => $flex ? $spacing : "0"};
`;
var Snackbar = ({
  /* Behaviour ---------------------------------------------*/
  open,
  // controlled flag
  onClose,
  // callback when fully hidden
  autoHideDuration = 4e3,
  noStack = false,
  /* Content -----------------------------------------------*/
  message,
  children,
  /* Styling + passthrough ---------------------------------*/
  preset: p,
  className,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  const surface = useSurface(
    (s) => ({
      registerChild: s.registerChild,
      unregisterChild: s.unregisterChild
    }),
    import_shallow9.shallow
  );
  const ref = (0, import_react32.useRef)(null);
  const id = (0, import_react32.useId)();
  const [internalOpen, setInternalOpen] = (0, import_react32.useState)(
    open !== void 0 ? open : true
  );
  const visible = open !== void 0 ? open : internalOpen;
  const [exiting, setExiting] = (0, import_react32.useState)(false);
  (0, import_react32.useLayoutEffect)(() => {
    if (!ref.current) return;
    const node = ref.current;
    const noop = () => {
    };
    surface.registerChild(id, node, noop);
    return () => surface.unregisterChild(id);
  }, []);
  (0, import_react32.useEffect)(() => {
    if (!visible || autoHideDuration == null) return;
    const timer = setTimeout(() => handleClose(), autoHideDuration);
    return () => clearTimeout(timer);
  }, [visible, autoHideDuration]);
  const handleClose = () => {
    if (open !== void 0) {
      onClose?.();
      return;
    }
    setExiting(true);
    setTimeout(() => {
      setInternalOpen(false);
      setExiting(false);
      onClose?.();
    }, 200);
  };
  if (!visible && !exiting) return null;
  const body = children ?? (message != null ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Typography, { variant: "body", autoSize: true, children: message }) : null);
  const classes = [p ? preset(p) : "", className].filter(Boolean).join(" ") || void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(SnackbarCtx.Provider, { value: handleClose, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
    Root8,
    {
      ref,
      ...rest,
      $visible: !exiting && visible,
      $flex: !noStack,
      $spacing: theme.spacing(1),
      $outline: theme.colors.primary,
      $bg: theme.colors.background,
      className: classes,
      style,
      children: body
    }
  ) });
};

// src/components/widgets/SpeedDial.tsx
var import_react33 = require("react");
var import_jsx_runtime38 = require("react/jsx-runtime");
var Container = styled("div")`
  position: fixed;
  bottom  : 1rem;
  right   : 1rem;
  display : flex;
  align-items: flex-end; /* Stick to bottom/right edge */
  gap: ${({ $gap }) => $gap};
`;
var ActionButton = styled("button")`
  border       : none;
  width        : 3rem;
  height       : 3rem;
  border-radius: 50%;
  background   : ${({ $bg }) => $bg};
  color        : ${({ $color }) => $color};
  cursor       : pointer;
  /* Mobile tidy-ups */
  -webkit-tap-highlight-color: transparent; /* ⬅︎ kills blue flash */
  outline      : none;

  transition:
    background 0.2s ease,
    transform  0.1s ease;

  &:active:not(:disabled) { transform: scale(0.94); }
`;
var SpeedDial = ({
  icon,
  actions,
  direction = "up",
  preset: p,
  className,
  ...rest
}) => {
  const { theme } = useTheme();
  const [open, setOpen] = (0, import_react33.useState)(false);
  const presetCls = p ? preset(p) : "";
  const bg = theme.colors.primary;
  const text = theme.colors.primaryText;
  const dirMap = {
    up: "column",
    // actions above, FAB bottom
    down: "column-reverse",
    // actions below, FAB top
    left: "row",
    // actions left,  FAB right
    right: "row-reverse"
    // actions right, FAB left
  };
  return /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(
    Container,
    {
      ...rest,
      $gap: "0.5rem",
      style: { flexDirection: dirMap[direction] },
      className: [presetCls, className].filter(Boolean).join(" "),
      children: [
        open && actions.map((a, idx) => /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          ActionButton,
          {
            onClick: a.onClick,
            $bg: bg,
            $color: text,
            title: a.label,
            children: a.icon
          },
          idx
        )),
        /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
          ActionButton,
          {
            onClick: () => setOpen((o) => !o),
            $bg: bg,
            $color: text,
            "aria-label": "Speed dial",
            children: icon
          }
        )
      ]
    }
  );
};

// src/components/widgets/Stepper.tsx
var import_jsx_runtime39 = require("react/jsx-runtime");
var Root9 = styled("div")`
  display: flex;
  gap: 0.5rem;
  counter-reset: step;
`;
var StepItem = styled("div")`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.875rem;
  font-weight: ${({ $active }) => $active ? "bold" : "normal"};
  color: inherit;

  &::before {
    counter-increment: step;
    content: counter(step);
    border: 1px solid ${({ $primary }) => $primary};
    background: ${({ $active, $primary }) => $active ? $primary : "transparent"};
    color: ${({ $active }) => $active ? "#fff" : "inherit"};
    border-radius: 999px;
    width: 1.5rem;
    height: 1.5rem;
    line-height: 1.5rem;
    text-align: center;
  }
`;
var Stepper = ({
  steps,
  active = 0,
  preset: p,
  className,
  style,
  ...rest
}) => {
  const { theme } = useTheme();
  const presetClass = p ? preset(p) : "";
  const primary = theme.colors.primary;
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
    Root9,
    {
      ...rest,
      $primary: primary,
      className: [presetClass, className].filter(Boolean).join(" "),
      style,
      children: steps.map((label, idx) => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(StepItem, { $active: idx === active, $primary: primary, children: label }, idx))
    }
  );
};

// src/components/widgets/Dropzone.tsx
var import_react34 = require("react");
var import_react_dropzone = require("react-dropzone");
var import_jsx_runtime40 = require("react/jsx-runtime");
var Dropzone = ({
  accept,
  maxFiles,
  multiple = true,
  showPreviews = true,
  showFileList = false,
  onDrop: onDropCb,
  onFilesChange,
  preset: p,
  fullWidth = false,
  className,
  style,
  ...rest
}) => {
  const [files, setFiles] = (0, import_react34.useState)([]);
  const { theme } = useTheme();
  const handleDrop = (0, import_react34.useCallback)(
    (accepted, _rej, _evt) => {
      const next = multiple ? [...files, ...accepted] : accepted.slice(0, 1);
      const limited = maxFiles ? next.slice(0, maxFiles) : next;
      setFiles(limited);
      onFilesChange?.(limited);
      onDropCb?.(accepted, _rej, _evt);
    },
    [files, multiple, maxFiles, onFilesChange, onDropCb]
  );
  const {
    getRootProps,
    getInputProps,
    isDragActive
  } = (0, import_react_dropzone.useDropzone)({ accept, maxFiles, multiple, onDrop: handleDrop });
  const presetCls = p ? preset(p) : "";
  const previews = showPreviews && files.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Grid_default, { columns: 4, gap: 0.5, style: { width: "100%" }, children: files.map((f, i) => /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    "img",
    {
      src: URL.createObjectURL(f),
      alt: f.name,
      style: { width: "100%", height: "auto", borderRadius: 4 }
    },
    i
  )) });
  const iconMap = {
    jpg: "carbon:image",
    jpeg: "carbon:image",
    png: "carbon:image",
    gif: "carbon:image",
    svg: "carbon:image",
    bmp: "carbon:image",
    webp: "carbon:image",
    mp3: "carbon:music",
    wav: "carbon:music",
    ogg: "carbon:music",
    flac: "carbon:music",
    mp4: "carbon:video",
    webm: "carbon:video",
    mov: "carbon:video",
    mkv: "carbon:video",
    pdf: "carbon:pdf",
    doc: "carbon:document",
    docx: "carbon:document",
    txt: "carbon:document",
    csv: "carbon:csv",
    xls: "carbon:csv",
    xlsx: "carbon:csv",
    zip: "carbon:zip",
    rar: "carbon:zip",
    gz: "carbon:zip"
  };
  const fileIcon = (name) => {
    const ext = name.split(".").pop()?.toLowerCase() ?? "";
    return iconMap[ext] ?? "carbon:document";
  };
  const fileList = showFileList && !showPreviews && files.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Stack_default, { spacing: 0.5, style: { width: "100%" }, children: files.map((f, i) => /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(Stack_default, { direction: "row", spacing: 0.5, style: { alignItems: "center" }, children: [
    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Icon_default, { icon: fileIcon(f.name) }),
    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("span", { style: { overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" }, children: f.name })
  ] }, i)) });
  const rootProps = getRootProps();
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(
    Panel_default,
    {
      ...rest,
      ...rootProps,
      ref: rootProps.ref,
      variant: "alt",
      fullWidth,
      style: {
        width: fullWidth ? `calc(100% - ${theme.spacing(1)} * 2)` : void 0,
        textAlign: "center",
        cursor: "pointer",
        ...style
      },
      className: [presetCls, className, isDragActive ? "drag-active" : ""].filter(Boolean).join(" "),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("input", { ...getInputProps() }),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Icon_default, { icon: "mdi:cloud-upload", size: "lg" }),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("div", { children: isDragActive ? "Drop files here\u2026" : "Drag files or click to browse" }),
        previews || fileList
      ]
    }
  );
};

// src/components/layout/Tabs.tsx
var import_react36 = __toESM(require("react"));

// src/components/widgets/Tooltip.tsx
var import_react35 = require("react");
var import_react_dom4 = require("react-dom");
var import_jsx_runtime41 = require("react/jsx-runtime");
var LONG_PRESS_MS = 600;
var activeTooltip = null;
var registerTooltip = (close) => {
  if (activeTooltip && activeTooltip !== close) activeTooltip();
  activeTooltip = close;
};
var unregisterTooltip = (close) => {
  if (activeTooltip === close) activeTooltip = null;
};
var GAP = 8;
var Wrapper11 = styled("span")`
  position: relative;
  display: inline-flex;
  /* ----- critical: never stretch in a flex column -------- */
  flex: 0 0 auto;
  align-self: flex-start;
`;
var Bubble = styled("div")`
  --gap: ${GAP}px;
  position: fixed;
  z-index: 9999;
  max-width: 22rem;
  padding: 0.4rem 0.7rem;
  border-radius: 4px;
  background: var(--tt-bg, #000);
  color: var(--tt-fg, #fff);
  font-size: 0.75rem;
  line-height: 1.3;
  pointer-events: none;

  opacity: ${({ $show }) => $show ? 1 : 0};
  transition: opacity 140ms ease, transform 140ms ease;

  transform-origin: ${({ $placement }) => ({
  top: "bottom center",
  bottom: "top center",
  left: "center right",
  right: "center left"
})[$placement]};
  transform: ${({ $show, $placement }) => {
  const dist = $show ? 0 : {
    top: 4,
    bottom: -4,
    left: 4,
    right: -4
  }[$placement];
  return $placement === "top" || $placement === "bottom" ? `translate(-50%, ${dist}px)` : `translate(${dist}px, -50%)`;
}};
`;
var Arrow = styled("span")`
  --s: 8px;
  position: absolute;
  width: var(--s);
  height: var(--s);
  background: var(--tt-bg, #000);
  transform: rotate(45deg);

  ${({ $placement }) => ({
  top: `bottom: calc(-0.5 * var(--s)); left: 50%; transform: translateX(-50%) rotate(45deg);`,
  bottom: `top:    calc(-0.5 * var(--s)); left: 50%; transform: translateX(-50%) rotate(45deg);`,
  left: `right:  calc(-0.5 * var(--s)); top: 50%; transform: translateY(-50%) rotate(45deg);`,
  right: `left:   calc(-0.5 * var(--s)); top: 50%; transform: translateY(-50%) rotate(45deg);`
})[$placement]}
`;
var Tooltip = ({
  title,
  placement = "top",
  arrow = true,
  enterDelay = 100,
  leaveDelay = 100,
  open: controlled,
  defaultOpen = false,
  disableHoverListener = false,
  disableFocusListener = false,
  disableTouchListener = false,
  onOpen,
  onClose,
  preset: presetKey,
  children
}) => {
  const { theme } = useTheme();
  const id = (0, import_react35.useId)();
  const hasPreset = Boolean(presetKey);
  const wrapperRef = (0, import_react35.useRef)(null);
  const bubbleRef = (0, import_react35.useRef)(null);
  const [pos, setPos] = (0, import_react35.useState)({ top: 0, left: 0 });
  const [internalShow, setInternalShow] = (0, import_react35.useState)(defaultOpen);
  const show = controlled ?? internalShow;
  const inT = (0, import_react35.useRef)(null);
  const outT = (0, import_react35.useRef)(null);
  const clear = () => {
    if (inT.current) clearTimeout(inT.current);
    if (outT.current) clearTimeout(outT.current);
  };
  const close = (0, import_react35.useCallback)(() => {
    if (controlled === void 0) setInternalShow(false);
    onClose?.();
    unregisterTooltip(close);
  }, [controlled, onClose]);
  const open = (0, import_react35.useCallback)(() => {
    if (activeTooltip && activeTooltip !== close) activeTooltip();
    if (controlled === void 0) setInternalShow(true);
    onOpen?.();
    registerTooltip(close);
  }, [controlled, onOpen, close]);
  const handleOutside = (0, import_react35.useCallback)((e) => {
    if (!wrapperRef.current?.contains(e.target)) {
      close();
    }
  }, [close]);
  const handleEnter = () => {
    clear();
    inT.current = setTimeout(open, enterDelay);
  };
  const handleLeave = () => {
    clear();
    outT.current = setTimeout(close, leaveDelay);
  };
  const touchTimer = (0, import_react35.useRef)(null);
  const wasOpen = (0, import_react35.useRef)(false);
  const handlePointerDown = (e) => {
    if (e.pointerType !== "touch" || disableTouchListener) return;
    wasOpen.current = show;
    if (touchTimer.current) clearTimeout(touchTimer.current);
    touchTimer.current = setTimeout(() => {
      if (!show) open();
    }, LONG_PRESS_MS);
  };
  const handlePointerUp = (e) => {
    if (e.pointerType !== "touch" || disableTouchListener) return;
    if (touchTimer.current) clearTimeout(touchTimer.current);
    if (wasOpen.current) {
      close();
    }
  };
  const handlePointerCancel = (e) => {
    if (e.pointerType !== "touch" || disableTouchListener) return;
    if (touchTimer.current) clearTimeout(touchTimer.current);
  };
  (0, import_react35.useEffect)(() => {
    return () => {
      clear();
      if (touchTimer.current) clearTimeout(touchTimer.current);
      unregisterTooltip(close);
    };
  }, [close]);
  (0, import_react35.useEffect)(() => {
    if (controlled !== void 0) {
      if (show) registerTooltip(close);
      else unregisterTooltip(close);
    }
  }, [show, controlled, close]);
  (0, import_react35.useEffect)(() => {
    if (!show) return;
    document.addEventListener("pointerdown", handleOutside);
    return () => {
      document.removeEventListener("pointerdown", handleOutside);
    };
  }, [show, handleOutside]);
  (0, import_react35.useLayoutEffect)(() => {
    if (!show) return;
    const calc = () => {
      const wrapper = wrapperRef.current;
      const bubble = bubbleRef.current;
      if (!wrapper || !bubble) return;
      const rect = wrapper.getBoundingClientRect();
      const b = bubble.getBoundingClientRect();
      let top = 0;
      let left = 0;
      switch (placement) {
        case "top":
          top = rect.top - b.height - GAP;
          left = rect.left + rect.width / 2;
          break;
        case "bottom":
          top = rect.bottom + GAP;
          left = rect.left + rect.width / 2;
          break;
        case "left":
          top = rect.top + rect.height / 2;
          left = rect.left - b.width - GAP;
          break;
        case "right":
          top = rect.top + rect.height / 2;
          left = rect.right + GAP;
          break;
      }
      setPos({ top, left });
    };
    calc();
    window.addEventListener("scroll", calc, true);
    window.addEventListener("resize", calc);
    return () => {
      window.removeEventListener("scroll", calc, true);
      window.removeEventListener("resize", calc);
    };
  }, [show, placement]);
  const presetClasses = presetKey ? preset(presetKey) : "";
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(
    Wrapper11,
    {
      ref: wrapperRef,
      onMouseEnter: !disableHoverListener ? handleEnter : void 0,
      onMouseLeave: !disableHoverListener ? handleLeave : void 0,
      onFocus: !disableFocusListener ? open : void 0,
      onBlur: !disableFocusListener ? close : void 0,
      onPointerDown: handlePointerDown,
      onPointerUp: handlePointerUp,
      onPointerCancel: handlePointerCancel,
      onPointerLeave: handlePointerCancel,
      "aria-describedby": show ? `tooltip-${id}` : void 0,
      children: [
        children,
        (0, import_react_dom4.createPortal)(
          /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(
            Bubble,
            {
              ref: bubbleRef,
              $show: show,
              $placement: placement,
              role: "tooltip",
              id: `tooltip-${id}`,
              className: presetClasses,
              style: {
                top: pos.top,
                left: pos.left,
                ...hasPreset ? void 0 : {
                  "--tt-bg": theme.colors.text,
                  "--tt-fg": theme.colors.background
                }
              },
              children: [
                title,
                arrow && /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Arrow, { $placement: placement })
              ]
            }
          ),
          document.body
        )
      ]
    }
  );
};

// src/components/layout/Tabs.tsx
var import_jsx_runtime42 = require("react/jsx-runtime");
var TabsCtx = (0, import_react36.createContext)(null);
var useTabs = () => {
  const ctx = (0, import_react36.useContext)(TabsCtx);
  if (!ctx) throw new Error("Tabs.Tab / Tabs.Panel must be inside <Tabs>");
  return ctx;
};
var Root10 = styled("div")`
  width: 100%;
  display: grid;
  margin: ${({ $gap }) => $gap};
  & > * {
    padding: ${({ $gap }) => $gap};
  }

  ${({ $orientation, $placement }) => $orientation === "horizontal" ? `
    /* rows: tab-strip + panel */
    grid-template-rows: ${$placement === "top" ? "auto 1fr" : "1fr auto"};
  ` : `
    /* cols: tab-strip + panel */
    grid-template-columns: ${$placement === "left" ? "max-content 1fr" : "1fr max-content"};
    align-items: start; /* keep panel aligned to top of tabs */
  `}

  /* Gutter only for vertical-left layout */
  ${({ $orientation, $placement }) => $orientation === "vertical" && $placement === "left" ? "column-gap: 1rem;" : ""}
`;
var TabList = styled("div")`
  display: flex;
  flex-direction: ${({ $orientation }) => $orientation === "vertical" ? "column" : "row"};
  gap: 0;

  ${({ $orientation, $center }) => {
  if ($orientation === "vertical")
    return $center ? "align-self: stretch; height: 100%; justify-content: center;" : "width: max-content;";
  return $center ? "justify-content: center;" : "";
}}
`;
var TabBtn = styled("button")`
  background: transparent;
  border: none;
  color: inherit;
  font: inherit;
  padding: 0.75rem 1.25rem;
  cursor: pointer;
  appearance: none;

  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;

  ${({ $orient }) => $orient === "vertical" ? "width: 100%;" : "min-width: 4rem;"}

  position: relative;
  text-align: center;

  &:focus-visible {
    outline: 2px solid ${({ $primary }) => $primary};
    outline-offset: 2px;
  }

  &::after {
    content: '';
    position: absolute;
    ${({ $orient }) => $orient === "horizontal" ? `left: 0; right: 0; bottom: -1px; height: 2px;` : `top: 0; bottom: 0; right: -1px; width: 2px;`}
    background: ${({ $primary, $active }) => $active ? $primary : "transparent"};
    transition: background 150ms ease;
  }
`;
var Panel3 = styled("div")`
  padding: 1rem 0;

  /* Strictly vertical scrolling */
  overflow-x: hidden;
  overflow-y: auto;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE & Edge */
  &::-webkit-scrollbar { display: none; }

  box-sizing: border-box;
  min-height: 0;
  max-height: 100%;
  max-width: 100%;
`;
var Tabs = ({
  active: controlledActive,
  defaultActive = 0,
  orientation = "horizontal",
  placement: placementProp,
  onTabChange,
  centered = false,
  preset: p,
  className,
  children,
  ...divProps
}) => {
  const { theme } = useTheme();
  const placement = placementProp ?? (orientation === "horizontal" ? "top" : "left");
  const controlled = controlledActive !== void 0;
  const [self, setSelf] = (0, import_react36.useState)(defaultActive);
  const active = controlled ? controlledActive : self;
  const refs = (0, import_react36.useRef)({});
  const registerTab = (0, import_react36.useCallback)(
    (i, el) => refs.current[i] = el,
    []
  );
  const setActive = (0, import_react36.useCallback)(
    (i) => {
      if (!controlled) setSelf(i);
      onTabChange?.(i);
      refs.current[i]?.focus();
    },
    [controlled, onTabChange]
  );
  const tabs = [];
  const panels = [];
  import_react36.default.Children.forEach(children, (child) => {
    if (!import_react36.default.isValidElement(child)) return;
    const name = child.type.displayName;
    if (name === "Tabs.Tab")
      tabs.push(
        import_react36.default.cloneElement(child, { index: tabs.length, key: tabs.length })
      );
    if (name === "Tabs.Panel")
      panels.push(
        import_react36.default.cloneElement(child, { index: panels.length, key: panels.length })
      );
  });
  const ctx = (0, import_react36.useMemo)(
    () => ({
      active,
      setActive,
      orientation,
      registerTab,
      totalTabs: tabs.length
    }),
    [active, orientation, setActive, tabs.length]
  );
  const cls = [p ? preset(p) : "", className].filter(Boolean).join(" ");
  const gap = theme.spacing(1);
  const stripFirst = orientation === "horizontal" && placement === "top" || orientation === "vertical" && placement === "left";
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(TabsCtx.Provider, { value: ctx, children: /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(
    Root10,
    {
      ...divProps,
      $orientation: orientation,
      $placement: placement,
      $gap: gap,
      className: cls,
      children: [
        stripFirst && /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(TabList, { $orientation: orientation, $center: centered, children: tabs }),
        /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(Panel3, { children: panels }),
        !stripFirst && /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(TabList, { $orientation: orientation, $center: centered, children: tabs })
      ]
    }
  ) });
};
var Tab = (0, import_react36.forwardRef)(
  ({ index = 0, label, tooltip, preset: p, className, onKeyDown, onClick, ...rest }, ref) => {
    const { theme } = useTheme();
    const { active, setActive, orientation, registerTab, totalTabs } = useTabs();
    const selected = active === index;
    const nav = (e) => {
      const horiz = orientation === "horizontal";
      const prev = horiz ? "ArrowLeft" : "ArrowUp";
      const next = horiz ? "ArrowRight" : "ArrowDown";
      if (e.key === prev || e.key === next) {
        e.preventDefault();
        setActive((active + (e.key === next ? 1 : -1) + totalTabs) % totalTabs);
      }
      onKeyDown?.(e);
    };
    const content = label ?? rest.children;
    const btn = /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
      TabBtn,
      {
        ...rest,
        ref: (el) => {
          registerTab(index, el);
          if (typeof ref === "function") ref(el);
          else if (ref) ref.current = el;
        },
        role: "tab",
        id: `tab-${index}`,
        "aria-selected": selected,
        "aria-controls": `panel-${index}`,
        tabIndex: selected ? 0 : -1,
        onClick: (e) => {
          setActive(index);
          onClick?.(e);
        },
        onKeyDown: nav,
        $active: selected,
        $primary: theme.colors.primary,
        $orient: orientation,
        className: [p ? preset(p) : "", className].filter(Boolean).join(" "),
        children: typeof content === "string" || typeof content === "number" ? /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(Typography, { variant: "button", noSelect: true, children: content }) : content
      }
    );
    return tooltip ? /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(Tooltip, { title: tooltip, children: btn }) : btn;
  }
);
Tab.displayName = "Tabs.Tab";
var TabPanel = ({
  index = 0,
  keepMounted = false,
  preset: p,
  className,
  children,
  ...rest
}) => {
  const { active } = useTabs();
  if (active !== index && !keepMounted) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
    "div",
    {
      ...rest,
      role: "tabpanel",
      id: `panel-${index}`,
      "aria-labelledby": `tab-${index}`,
      className: [p ? preset(p) : "", className].filter(Boolean).join(" "),
      children
    }
  );
};
TabPanel.displayName = "Tabs.Panel";
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// src/components/widgets/Tree.tsx
var import_react37 = require("react");
var import_jsx_runtime43 = require("react/jsx-runtime");
var Root11 = styled("ul")`
  list-style: none;
  margin: 0;
  padding: 0;
`;
var ItemRow = styled("div")`
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.25rem 0.5rem 0.25rem ${({ $level }) => $level * 1.25}rem;
  cursor: pointer;
  user-select: none;
  ${({ $hoverBg }) => `@media(hover:hover){&:hover{background:${$hoverBg};}}`}
  ${({ $selected, $selectedBg }) => $selected ? `background:${$selectedBg};` : ""}
  &:focus-visible {
    outline: 2px solid currentColor;
    outline-offset: 2px;
  }
`;
var ExpandIcon = styled("span")`
  display: inline-block;
  width: 1em;
  height: 1em;
  transform: rotate(${({ $open }) => $open ? 90 : 0}deg);
  transition: transform 150ms ease;
`;
var Branch = styled("ul")`
  list-style: none;
  margin: 0;
  padding-left: ${({ $root }) => $root ? 0 : "1rem"};
  position: relative;
`;
var BranchItem = styled("li")`
  position: relative;
  margin: 0;
  padding: 0;
  ${({ $root, $line }) => !$root && `
      &::before {
        content: '';
        position: absolute;
        top: 0.875rem;
        left: calc(-1rem + 0.75em);
        width: calc(1.25rem - 0.75em);
        border-top: 1px solid ${$line};
      }
    `}
  &::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: calc(-1rem + 0.75em);
    border-left: 1px solid ${({ $line }) => $line};
  }
`;
var ListRow = styled("div")`
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.25rem 0.5rem;
  cursor: pointer;
  user-select: none;
  ${({ $hoverBg }) => `@media(hover:hover){&:hover{background:${$hoverBg};}}`}
  ${({ $selected, $selectedBg }) => $selected ? `background:${$selectedBg};` : ""}
  &:focus-visible {
    outline: 2px solid currentColor;
    outline-offset: 2px;
  }
`;
var BoxIcon = styled("span")`
  display: inline-block;
  width: 0.75em;
  height: 0.75em;
  border: 1px solid ${({ $line }) => $line};
  background: ${({ $open, $fill }) => $open ? $fill : "transparent"};
  margin-right: 0.25rem;
  box-sizing: border-box;
`;
function Tree({
  nodes,
  getLabel,
  defaultExpanded = [],
  expanded: expandedProp,
  onExpandedChange,
  selected: selectedProp,
  defaultSelected,
  onNodeSelect,
  variant = "chevron",
  preset: p,
  className,
  ...rest
}) {
  const { theme } = useTheme();
  const controlledExpand = expandedProp !== void 0;
  const [selfExpanded, setSelfExpanded] = (0, import_react37.useState)(() => new Set(defaultExpanded));
  const expanded = controlledExpand ? new Set(expandedProp) : selfExpanded;
  const [focused, setFocused] = (0, import_react37.useState)(null);
  const controlled = selectedProp !== void 0;
  const [selfSelected, setSelfSelected] = (0, import_react37.useState)(
    defaultSelected ?? null
  );
  const selected = controlled ? selectedProp : selfSelected;
  const hoverBg = toHex(
    mix(toRgb(theme.colors.primary), toRgb(theme.colors.background), 0.4)
  );
  const selectedBg = toHex(
    mix(toRgb(theme.colors.primary), toRgb(theme.colors.background), 0.2)
  );
  const flat = (0, import_react37.useMemo)(() => {
    const res = [];
    const walk = (items, level) => {
      for (const it of items) {
        res.push({ node: it, level });
        if (it.children && expanded.has(it.id)) walk(it.children, level + 1);
      }
    };
    walk(nodes, 0);
    return res;
  }, [nodes, expandedProp, selfExpanded]);
  const refs = (0, import_react37.useRef)({});
  const focusItem = (id) => {
    setFocused(id);
    refs.current[id]?.focus();
  };
  const toggle = (id) => {
    const apply = (prev) => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    };
    if (controlledExpand) {
      const next = apply(expanded);
      onExpandedChange?.([...next]);
    } else {
      setSelfExpanded((prev) => {
        const next = apply(prev);
        onExpandedChange?.([...next]);
        return next;
      });
    }
  };
  const line = theme.colors.backgroundAlt;
  const visibleIds = flat.map((f) => f.node.id);
  const keyNav = (e) => {
    if (!focused) return;
    const idx = visibleIds.indexOf(focused);
    if (idx === -1) return;
    const current = flat[idx];
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        if (idx < visibleIds.length - 1) focusItem(visibleIds[idx + 1]);
        break;
      case "ArrowUp":
        e.preventDefault();
        if (idx > 0) focusItem(visibleIds[idx - 1]);
        break;
      case "ArrowRight":
        e.preventDefault();
        if (current.node.children) {
          if (!expanded.has(current.node.id)) toggle(current.node.id);
          else if (current.node.children.length)
            focusItem(current.node.children[0].id);
        }
        break;
      case "ArrowLeft":
        e.preventDefault();
        if (expanded.has(current.node.id)) toggle(current.node.id);
        else {
          for (let i = idx - 1; i >= 0; i--) {
            const candidate = flat[i];
            if (candidate.level < current.level) {
              focusItem(candidate.node.id);
              break;
            }
          }
        }
        break;
      case "Enter":
      case " ":
        e.preventDefault();
        if (!controlled) setSelfSelected(current.node.id);
        onNodeSelect?.(current.node.data);
        break;
    }
  };
  const renderBranch = (items, level) => /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Branch, { role: level ? "group" : void 0, $line: line, $root: level === 0, children: items.map((node) => /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(BranchItem, { $line: line, $root: level === 0, role: "none", children: [
    /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(
      ListRow,
      {
        ref: (el) => {
          refs.current[node.id] = el;
        },
        role: "treeitem",
        "aria-expanded": node.children ? expanded.has(node.id) : void 0,
        "aria-selected": selected === node.id,
        tabIndex: focused === node.id ? 0 : -1,
        $hoverBg: hoverBg,
        $selectedBg: selectedBg,
        $selected: selected === node.id,
        onClick: () => {
          focusItem(node.id);
          if (!controlled) setSelfSelected(node.id);
          onNodeSelect?.(node.data);
        },
        onDoubleClick: () => node.children && toggle(node.id),
        children: [
          variant === "list" && node.children && /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
            BoxIcon,
            {
              "aria-hidden": true,
              $open: expanded.has(node.id),
              $line: line,
              $fill: theme.colors.secondary,
              onClick: (e) => {
                e.stopPropagation();
                toggle(node.id);
              }
            }
          ),
          variant === "files" && /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
            Icon_default,
            {
              icon: node.children ? expanded.has(node.id) ? "carbon:folder-open" : "carbon:folder" : "carbon:document",
              size: 16,
              style: { marginRight: "0.25rem" },
              "aria-hidden": true,
              onClick: node.children ? (e) => {
                e.stopPropagation();
                toggle(node.id);
              } : void 0
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Typography_default, { variant: "body", family: "body", style: { display: "inline" }, children: getLabel(node.data) })
        ]
      }
    ),
    node.children && expanded.has(node.id) && renderBranch(node.children, level + 1)
  ] }, node.id)) });
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
    Root11,
    {
      ...rest,
      role: "tree",
      tabIndex: 0,
      onKeyDown: keyNav,
      $border: theme.colors.backgroundAlt,
      className: [p ? preset(p) : "", className].filter(Boolean).join(" "),
      children: variant === "chevron" ? flat.map(({ node, level }) => /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("li", { role: "none", children: /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(
        ItemRow,
        {
          ref: (el) => {
            refs.current[node.id] = el;
          },
          role: "treeitem",
          "aria-expanded": node.children ? expanded.has(node.id) : void 0,
          "aria-selected": selected === node.id,
          tabIndex: focused === node.id ? 0 : -1,
          $level: level,
          $hoverBg: hoverBg,
          $selectedBg: selectedBg,
          $selected: selected === node.id,
          onClick: () => {
            focusItem(node.id);
            if (!controlled) setSelfSelected(node.id);
            onNodeSelect?.(node.data);
          },
          onDoubleClick: () => node.children && toggle(node.id),
          children: [
            node.children && /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
              ExpandIcon,
              {
                "aria-hidden": true,
                $open: expanded.has(node.id),
                onClick: (e) => {
                  e.stopPropagation();
                  toggle(node.id);
                },
                children: "\u25B6"
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Typography_default, { variant: "body", family: "body", style: { display: "inline" }, children: getLabel(node.data) })
          ]
        }
      ) }, node.id)) : renderBranch(nodes, 0)
    }
  );
}

// src/system/createFormStore.ts
var import_traditional5 = require("zustand/traditional");
function createFormStore(initial) {
  return (0, import_traditional5.createWithEqualityFn)((set) => ({
    values: initial,
    setField: (key, value) => set((state) => ({
      values: { ...state.values, [key]: value }
    })),
    reset: () => set({ values: initial })
  }));
}

// src/system/createInitialTheme.ts
var import_react38 = require("react");

// src/helpers/fontLoader.ts
var loadedFonts = /* @__PURE__ */ new Set();
var customFaces = /* @__PURE__ */ new Map();
function injectFontLinks(fonts, options = {}) {
  const { preload = true } = options;
  const added = [];
  const googleFonts = fonts.filter((f) => typeof f === "string");
  if (googleFonts.length && !document.getElementById("valet-fonts-preconnect")) {
    const preconnect1 = document.createElement("link");
    preconnect1.id = "valet-fonts-preconnect";
    preconnect1.rel = "preconnect";
    preconnect1.href = "https://fonts.googleapis.com";
    document.head.appendChild(preconnect1);
    const preconnect2 = document.createElement("link");
    preconnect2.id = "valet-fonts-preconnect-gstatic";
    preconnect2.rel = "preconnect";
    preconnect2.href = "https://fonts.gstatic.com";
    preconnect2.crossOrigin = "anonymous";
    document.head.appendChild(preconnect2);
  }
  fonts.forEach((font) => {
    if (typeof font === "string") {
      if (!font || loadedFonts.has(font)) return;
      const formatted = font.replace(/ /g, "+");
      const href = `https://fonts.googleapis.com/css2?family=${formatted}:wght@400;700&display=swap`;
      if (preload) {
        const preloadLink = document.createElement("link");
        preloadLink.rel = "preload";
        preloadLink.as = "style";
        preloadLink.href = href;
        preloadLink.crossOrigin = "anonymous";
        document.head.appendChild(preloadLink);
        added.push(preloadLink);
      }
      const link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = href;
      link.crossOrigin = "anonymous";
      document.head.appendChild(link);
      added.push(link);
      loadedFonts.add(font);
    } else {
      if (!font.name || loadedFonts.has(font.name)) return;
      if (preload) {
        const preloadLink = document.createElement("link");
        preloadLink.rel = "preload";
        preloadLink.as = "font";
        preloadLink.href = font.src;
        preloadLink.crossOrigin = "anonymous";
        document.head.appendChild(preloadLink);
        added.push(preloadLink);
      }
      const face = new FontFace(font.name, `url(${font.src})`);
      document.fonts.add(face);
      face.load().catch(() => {
      });
      customFaces.set(font.name, face);
      loadedFonts.add(font.name);
    }
  });
  return () => {
    added.forEach((el) => document.head.removeChild(el));
    fonts.forEach((f) => loadedFonts.delete(typeof f === "string" ? f : f.name));
  };
}
async function waitForFonts(fonts) {
  await Promise.all(
    fonts.map((font) => {
      if (typeof font === "string") {
        return document.fonts.load(`400 1em ${font}`);
      }
      const face = customFaces.get(font.name) || new FontFace(font.name, `url(${font.src})`);
      if (!customFaces.has(font.name)) {
        customFaces.set(font.name, face);
        document.fonts.add(face);
      }
      return face.load();
    })
  );
  if (document.fonts?.ready) {
    await document.fonts.ready;
  }
  await new Promise((r) => requestAnimationFrame(() => requestAnimationFrame(r)));
  await new Promise((r) => setTimeout(r, 200));
}

// src/system/createInitialTheme.ts
async function createInitialTheme(patch, extras = [], options) {
  const { setTheme } = useTheme.getState();
  const { start, finish } = useFonts.getState();
  const themePatch = { ...patch };
  if (patch.fonts) {
    themePatch.fonts = Object.fromEntries(
      Object.entries(patch.fonts).map(([k, v]) => [k, typeof v === "string" ? v : v.name])
    );
  }
  setTheme(themePatch);
  const { theme } = useTheme.getState();
  const fonts = (() => {
    const all = [
      patch.fonts?.heading || theme.fonts.heading,
      patch.fonts?.body || theme.fonts.body,
      patch.fonts?.mono || theme.fonts.mono,
      patch.fonts?.button || theme.fonts.button,
      ...extras
    ];
    const map = /* @__PURE__ */ new Map();
    all.forEach((f) => {
      const key = typeof f === "string" ? f : f.name;
      if (key) map.set(key, f);
    });
    return Array.from(map.values());
  })();
  injectFontLinks(fonts, options);
  start();
  await waitForFonts(fonts);
  finish();
}
function useInitialTheme(patch, extras = [], options) {
  (0, import_react38.useEffect)(() => {
    createInitialTheme(patch, extras, options);
  }, []);
}

// src/hooks/useGoogleFonts.ts
var import_react39 = require("react");
function useGoogleFonts(extras = [], options) {
  const start = useFonts((s) => s.start);
  const finish = useFonts((s) => s.finish);
  const themeFonts = useTheme((s) => s.theme.fonts);
  const fonts = (0, import_react39.useMemo)(() => {
    const all = [
      themeFonts.heading,
      themeFonts.body,
      themeFonts.mono,
      ...extras
    ];
    const map = /* @__PURE__ */ new Map();
    all.forEach((f) => {
      const key = typeof f === "string" ? f : f.name;
      if (!map.has(key)) map.set(key, f);
    });
    return Array.from(map.values());
  }, [themeFonts.heading, themeFonts.body, themeFonts.mono, JSON.stringify(extras)]);
  (0, import_react39.useInsertionEffect)(() => {
    start();
    return injectFontLinks(fonts, options);
  }, [fonts.join(","), options?.preload, start]);
  (0, import_react39.useEffect)(() => {
    let active = true;
    (async () => {
      try {
        await waitForFonts(fonts);
      } finally {
        if (active) finish();
      }
    })();
    return () => {
      active = false;
    };
  }, [fonts.join(","), finish]);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Accordion,
  AppBar,
  Avatar,
  Box,
  Button,
  Checkbox,
  DateSelector,
  Drawer,
  Dropzone,
  FormControl,
  Grid,
  Icon,
  IconButton,
  Image,
  Iterator,
  KeyModal,
  LLMChat,
  List,
  LoadingBackdrop,
  Markdown,
  MetroSelect,
  Modal,
  Pagination,
  Panel,
  ParallaxBackground,
  ParallaxLayer,
  ParallaxScroll,
  Progress,
  Radio,
  RadioGroup,
  RichChat,
  Select,
  Slider,
  Snackbar,
  SpeedDial,
  Stack,
  Stepper,
  Surface,
  Switch,
  Table,
  Tabs,
  TextField,
  Tooltip,
  Tree,
  Typography,
  Video,
  createFormStore,
  createInitialTheme,
  decrypt,
  definePreset,
  encrypt,
  globalSheet,
  keyframes,
  preset,
  presetHas,
  sendChat,
  styleCache,
  styled,
  useAIKey,
  useFonts,
  useForm,
  useGoogleFonts,
  useInitialTheme,
  useParallax,
  useSnackbar,
  useSurface,
  useTheme
});
